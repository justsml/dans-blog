---
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import AnalyticsTag from "../components/AnalyticsTag.astro";
import { GitHubIssueComments } from "../components/Comments";
import { CreatedModifiedLabel } from "../components/CreatedModifiedLabel";
import socialBanner from "../assets/social-banner.webp";

import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";
import AdditionalReading from "../components/AdditionalReading.astro";
import CategoryLink from "../components/CategoryLink.astro";
import { EditOnGitHubLink } from "../components/EditOnGitHubLink";
import path, { join } from "path";
import { autoScreenShot } from "../components/Screenshots/AutoScreenShot.ts";
import { mkdir } from "fs/promises";

type Props = {
  sourcePath: string;
  children: any[];

  slug: string;

  frontmatter?: {
    title: string;
    subTitle?: string;
    commentsKeyOverride?: string;
    date?: string;
    modified?: string;
    tags?: string[];
    social_image?: unknown;
    cover?: unknown;
    cover_full_width?: unknown;
    category?: string;
    related?: string[];
  };
};

const {
  title,
  subTitle,
  cover,
  cover_full_width,
  category,
  date,
  modified,
  commentsKeyOverride,
  related,
  social_image,
} = Astro.props.frontmatter! || Astro.props;

const slug = Astro.props.slug;

const modDate = modified ? new Date(modified) : null;
const modTime = modDate ? modDate.toISOString().split("T")[0] : "";
const pubTime = date ? new Date(date).toISOString().split("T")[0] : "";

// Add type guard for ImageMetadata
const isImageMetadata = (img: any): img is ImageMetadata =>
  typeof img === "object" && "src" in img && "width" in img && "height" in img;

const coverUrl =
    isImageMetadata(cover)
    ? (cover as ImageMetadata)
    : typeof cover === "string"
      ? cover
      : isImageMetadata(social_image)
        ? social_image
        : socialBanner;

const commentsKey = commentsKeyOverride || new URL(Astro.request.url).pathname;

const responsiveImgSizes_fullWidth = {
  widths: [720, 1280, 1920],
  sizes: `
    (max-width: 600px) 100vw,
    (max-width: 1200px) 80vw,
    60vw`,
};
const responsiveImgSizes_breakRight = {
  widths: [800, 1440, 1920],
  sizes: `
    (max-width: 600px) 100vw,
    (max-width: 1200px) 80vw,
    60vw`,
};

---

<html lang="en">
  <head>
    <BaseHead title={title} description={`${subTitle}`} image={coverUrl} />
    {modTime && <meta http-equiv="last-modified" content={modTime} />}
    {modTime && <meta property="article:modified_time" content={modTime} />}
    {pubTime && <meta property="article:published_time" content={pubTime} />}
  </head>
  <body>
    <Header className="content-grid article" date={date} modified={modified} />
    <main class="content-grid article">
      {title && <h1>{title}</h1>}
      {subTitle && <h2>{subTitle}</h2>}

      <aside class="skinny">
        <div class="info">
          <CreatedModifiedLabel client:idle date={date} modified={modified} />
          <CategoryLink category={category} />
        </div>
      </aside>

      {
        cover_full_width &&
        typeof cover_full_width === "object" &&
        "src" in cover_full_width ? (
          <Image
            class="full-width flow"
            src={cover_full_width as ImageMetadata}
            alt={title}
            format="webp"
            {...responsiveImgSizes_fullWidth}
          />
        ) : (
          cover &&
          typeof cover === "object" &&
          "src" in cover && (
            <div class="hero-image">
              <div class="hero-image-wrapper">
                <Image
                  src={cover as ImageMetadata}
                  alt={title}
                  {...responsiveImgSizes_breakRight}
                />
              </div>
            </div>
          )
        )
      }
      <slot />
    </main>

    <EditOnGitHubLink
      sourcePath={Astro.props.sourcePath}
      repoUri="https://github.com/justsml/dans-blog/tree/main/src/content/posts"
    />

    <AdditionalReading
      slugs={related}
      excludeSlugs={[slug]}
      className="default-links"
    />

    <div class="comments-wrapper full-width default-links">
      <GitHubIssueComments client:only="react" path={commentsKey} />
    </div>
    <Footer />
    <AnalyticsTag />
  </body><link
    rel="stylesheet"
    href="../files/fonts.css"
    media="print"
    onload="this.media='all'"
  />
  <script>
    declare global {
      interface Window {
        __updateCounts: () => boolean;
      }
    }
    import { QuestionStore } from "../components/QuizUI/QuestionStore";

    let $interval: NodeJS.Timeout | null = null;
    let intCount = 0;
    // Hackety hack to update the score-wrapper on quiz pages
    window.__updateCounts = () => {
      const quizUI = document.querySelectorAll(".quiz-ui");
      const questions = document.querySelectorAll("main .challenge");
      const isQuizPage = quizUI.length > 0;

      if (!isQuizPage || questions.length <= 0) return false; // Not a quiz page

      const scoreEls = document.querySelectorAll(".score");
      const scoreEl = scoreEls[0];
      const scoreWrapper = document.querySelector(".score-wrapper");
      const scoreLabel = document.querySelector(".score label");
      const correct = document.querySelectorAll("main .challenge.correct");
      const congratsMsg = document.querySelector(".congrats-message");

      // Add up the tries from [data-answer-count]
      const questionStore = getQuestionStore();

      const tries: number = questionStore
        ? questionStore.sumOfTries()
        : Array.from(document.querySelectorAll("[data-answer-count")).reduce(
            (acc, q) => {
              const tries = parseInt(
                q.getAttribute("data-answer-count") || "0",
                10,
              );
              return acc + tries;
            },
            0,
          );

      const isPerfect =
        questions.length === correct.length && tries === questions.length;

      if (isPerfect) {
        scoreEl?.classList.add("perfect");
        quizUI[0].classList.add("perfect");
      }

      if (scoreEls.length >= 2) console.error("Multiple score elements found");
      if (!scoreLabel) {
        console.error("Expected score label, not found");
        return false;
      }
      if (correct.length > 0) scoreEls[0].classList.add("active");

      if (questions.length === correct.length) {
        scoreEl.classList.add("all-correct");
        if (congratsMsg) {
          const winningMessage = isPerfect ? "WOW! Perfect!" : "All correct!";
          const hTag = isPerfect ? "h2" : "h3";
          congratsMsg.innerHTML = `<${hTag}>${winningMessage} ${correct.length} / ${questions.length} ${tries > 0 ? `<sup>(${tries} tries)</sup>` : ""}</${hTag}>`;
        }
        scoreWrapper?.classList.toggle("pulse");
        scoreEl?.classList.add("success");
      } else {
        scoreLabel.innerHTML = `${correct.length} / ${questions.length} ${tries > 0 ? `<sup>(${tries} tries)</sup>` : ""}`;
      }
      return true;
    };

    function getQuestionStore() {
      const store = QuestionStore(window.location.pathname);
      if (!store) return null;
      return store;
    }

    document.addEventListener("astro:page-load", function () {
      const quiz = document.querySelector(".quiz-ui");

      if (quiz) {
        const questionStore = getQuestionStore();
        const resetButton = document.querySelector("button.reset-quiz");
        if (resetButton) {
          resetButton.addEventListener("click", () => {
            console.log("Resetting quiz state for", location.pathname);
            questionStore?.reset();
            location.reload();
          });
        }

        $interval = setInterval(() => {
          intCount++;

          window.__updateCounts();

          if (intCount > 12) {
            // console.warn("Too many iterations, stopping interval");
            clearInterval($interval!);
            return;
          }
        }, 100);

        quiz.addEventListener("mousedown", () => {
          clearInterval($interval!);
        });
        quiz.addEventListener("click", () => {
          clearInterval($interval!);
          window.__updateCounts();
        });
      }
    });
  </script>
</html>

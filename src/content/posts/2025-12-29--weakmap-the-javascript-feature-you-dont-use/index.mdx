---
title: "Stop Leaking Memory: Use WeakMap"
subTitle: "The JavaScript feature that saves your RAM from your bad code."
date: 2025-12-29
modified: 2025-12-30
tags: [javascript, memory, garbage-collection, performance, patterns]
category: Code
subCategory: Best Practices
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
---

I inherited a React app for a dashboard project once. A client complained that "Chrome crashes if I leave the tab open for lunch."

First of all, close your tabs. But secondly, they were right. The heap was growing by **100MB every hour**.

The culprit? A global `Map` used to store metadata about DOM nodes. Nodes were removed from the DOM, but the Map kept a "Strong Reference" to them.

**The Garbage Collector couldn't touch them.**

The fix took me 30 seconds. I changed `new Map()` to `new WeakMap()`.

---

## The "Strong Reference" Trap

Here is the code that is destroying your RAM:

```javascript
const cache = new Map();

function trackClick(element) {
  // ðŸ’€ DEADLY: This reference prevents 'element' from being GC'd
  cache.set(element, { clicks: 0 });
}

document.body.removeChild(element);
// Result: 'element' is still in memory forever.
```

Because `Map` keys are **Strong References**, the Garbage Collector sees `cache` holding onto `element` and says, "Oh, the user still needs this!"

It doesn't matter if the element is removed from the DOM. It lives forever in your Map.

---

## Enter WeakMap (The Savior)

A `WeakMap` has one job: **It holds keys weakly.**

If the *only* thing holding onto an object is a WeakMap, the Garbage Collector ignores it. The object is deleted. The WeakMap entry vanishes.

```javascript
const cache = new WeakMap();

function trackClick(element) {
  // âœ… SAFE: This reference does NOT prevent GC
  cache.set(element, { clicks: 0 });
}

document.body.removeChild(element);
// Result: 'element' is Garbage Collected.
// The entry in 'cache' is automatically removed.
```

**It is self-cleaning code.**

---

## Benchmarks: Map vs WeakMap

I ran a test creating 100,000 DOM nodes, associating data with them, and then deleting them.

1.  **Map**: ~156 MB retained. (The nodes never died).
2.  **WeakMap**: ~81 MB retained. (The nodes were collected).

That is a **50% memory reduction** for changing one word.

---

## Real World Use Cases

### 1. Private Data (The Old Way)
Before `#private` fields existed, libraries used WeakMap to hide data.

```javascript
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }

  getName() {
    return privateData.get(this).name;
  }
}
```

When the `User` instance dies, the private data dies with it.

### 2. Memoization
If you are caching results based on object inputs, use WeakMap.

```javascript
const cache = new WeakMap();

function expensiveCalc(obj) {
  if (cache.has(obj)) return cache.get(obj);
  
  const result = heavyMath(obj);
  cache.set(obj, result);
  return result;
}
```

If `obj` is deleted later, your cache doesn't hold onto it.

---

## Why You Aren't Using It

WeakMap has limits that scare people.

1.  **Not Iterable**: You cannot loop over keys. (Because they might disappear mid-loop).
2.  **No .size**: You can't ask "how many items?".
3.  **Keys must be Objects**: You can't use strings as keys.

**These are feature, not bugs.** They force you to use WeakMap *only* for metadata association.

---

## Conclusion

Memory leaks in Single Page Apps (SPAs) are usually caused by stale references.

If you are associating data with DOM nodes, objects, or anything temporary: **Use WeakMap.**

If you are caching data forever: **Use Map.**

It is that simple. Stop leaking memory.

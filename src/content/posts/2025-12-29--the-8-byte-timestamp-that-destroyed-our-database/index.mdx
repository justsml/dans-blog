---
title: "Your Timestamp is a Lie"
subTitle: "Why 8 bytes of data destroyed our production database at 3 AM."
date: 2025-12-29
modified: 2025-12-30
tags: [postgres, postgresql, databases, timestamps, timezones, microservices, debugging]
category: Code
subCategory: Databases
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
---

It was 3:47 AM.

The Payment Service in Dublin logged a successful checkout at `14:00`.
The Order Service in New York logged the order creation at `09:00`.

Our fraud detection system looked at the difference, saw that the payment happened 5 hours "after" the order (or before? I can't even remember the math), and flagged every single transaction as fraudulent.

We lost $40,000 in revenue in 20 minutes.

The culprit? `TIMESTAMP WITHOUT TIME ZONE`.

---

## Understanding the Storage

Consider this: Postgres gives you two ways to store time:

1.  `TIMESTAMP` (8 bytes)
2.  `TIMESTAMPTZ` (8 bytes)

#### Question

If they have the same precision (microseconds) and the same storage size (8 bytes)... Where does the timezone info go? Secret shadow or off-the-books column? Some magic lookup table somewhere?

#### Answer: None of that.

The TZ version auto-converts the time to UTC on storage and back on retrieval.

To take advantage of that, each query should tell Postgres the local timezone.

### How?

1.  Set the Postgres `timezone` parameter per session.
2.  Use `SET TIME ZONE 'America/New_York';` at the start of each connection, query, or transaction.
3.  Let the Postgres driver handle it (if it supports it).

`TIMESTAMP` is a sticky note.
If you store `2025-01-01 10:00:00`, Postgres stores exactly that. It doesn't know if that's 10 AM in Tokyo or 10 AM in London.

`TIMESTAMPTZ` is a universal anchor.
It converts your input to UTC before storing it. It converts it back to your local time when you query it.

We were using the first one.

Because our servers were in different timezones (Dublin uses IST/GMT, New York uses EST), `NOW()` meant completely different things depending on which server you asked.

---

## The Microsecond Precision Lie

Even if you tackle timezones, you crash into precision issues.

*   Postgres stores microseconds (`.123456`)
*   JavaScript `Date` uses milliseconds (`.123`)

When we compared them:

```sql
SELECT * FROM orders WHERE created_at = $1
```

It returned 0 rows.

Why?
Database: `10:00:00.123000`
JavaScript: `10:00:00.123`

Wait, those look the same? Nope. In some drivers, the rounding logic creates phantom mismatches.

We were implicitly truncating data and wondering why our idempotency keys were failing.

---

## How to Fix It (The Nuclear Option)

We stopped asking nicely. We implemented a database trigger that bans untyped timestamps.

```sql
CREATE OR REPLACE FUNCTION check_timestamp_tz()
RETURNS event_trigger AS $$
BEGIN
  -- Reject tables with TIMESTAMP WITHOUT TIME ZONE
  IF EXISTS (SELECT 1 FROM ... WHERE type = 'timestamp without time zone') THEN
      RAISE EXCEPTION 'Use TIMESTAMPTZ. Do not argue.';
  END IF;
END;
$$ LANGUAGE plpgsql;
```

Extreme? Yes.
Effective? We haven't had a timezone bug in 2 years.

---

## The Lessons

1.  Always use `TIMESTAMPTZ`. There is zero performance penalty. It is the same size (8 bytes). It just works.
2.  Server time is UTC. If your servers are running on local time, change them. Now.
3.  Trust no one. If a client sends you a date string without an offset (`2025-01-01T10:00:00`), reject it. Request ISO-8601 with an offset (`2025-01-01T10:00:00Z`).

Time is hard. Don't make it harder by guessing.

---
title: "Your Timestamp is a Lie"
subTitle: "Understanding what you actually need to store about time"
date: 2025-12-29
modified: 2025-12-30
tags: [postgres, postgresql, databases, timestamps, timezones, microservices, debugging]
category: Code
subCategory: Databases
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
---

Choosing the right timestamp type in Postgres isn't about picking the "correct" one—it's about understanding what you actually need to store. Both `TIMESTAMP` and `TIMESTAMPTZ` take up exactly 8 bytes of storage with the same microsecond precision. The difference is in what question you're trying to answer.

## The Core Question: What Are You Recording?

Before reaching for a timestamp column, ask yourself: what does this data represent?

**Are you recording when something happened in absolute time?** Like "when did this payment complete?" or "when did the user click this button?" You need `TIMESTAMPTZ`. These are events that occurred at a specific moment in history, regardless of where anyone was when they happened.

**Are you recording a wall-clock time that's meaningful in itself?** Like "what time does this store open?" or "when should we send daily summary emails?" You might need `TIMESTAMP` (without timezone). These represent clock readings that should stay the same regardless of timezone conversions.

**Are you recording both the moment AND where/why it happened?** Like "when did the user submit this form, and from what timezone?" You need `TIMESTAMPTZ` for the moment, plus a separate text column for the timezone context. The timestamp tells you when it happened in absolute terms; the timezone field tells you where the user was.

## How TIMESTAMPTZ Actually Works

The trick with `TIMESTAMPTZ` is right there in the name: it's not "timestamp with timezone stored." It's "timestamp with timezone **support**." The column doesn't store timezone information at all.

What it does is **convert** whatever timestamp you give it to UTC before writing it to disk, then converts it back to your session's timezone when you read it. The timezone data lives in your connection settings, not in the column.

```sql
-- With session timezone set to 'America/New_York'
INSERT INTO events (happened_at) VALUES ('2025-01-15 14:00:00');
-- Postgres stores this as 2025-01-15 19:00:00 UTC

-- Later, with session timezone set to 'Europe/Dublin'
SELECT happened_at FROM events;
-- Returns 2025-01-15 19:00:00 (in Dublin time)
```

Everyone querying that timestamp sees the same moment in time, just expressed in their configured timezone.

## When TIMESTAMP (Without TZ) Makes Sense

Say you're building a scheduling system where businesses set their "daily report runs at 2:00 AM." If you store that as `TIMESTAMPTZ`, and the business moves from New York to Chicago, suddenly their reports start running an hour earlier by their wall clock.

For recurring schedules, recurring local times, or UI display preferences, `TIMESTAMP` makes sense because you care about the clock reading itself, not the absolute moment in time.

But be very careful: if you're ever going to compare these timestamps across records that might have been created in different timezones, you're setting yourself up for subtle bugs.

## The Precision Mismatch Problem

Even with the right timestamp type, precision matters. Postgres stores timestamps with microsecond precision: `10:00:00.123456`. JavaScript's `Date` object uses milliseconds: `10:00:00.123`.

This causes problems with equality checks:

```sql
SELECT * FROM orders WHERE created_at = $1
```

If the database has `10:00:00.123000` and your JavaScript code passes in `10:00:00.123`, they won't match. The driver might pad zeros, or it might not. This is especially problematic for idempotency checks where you're trying to find a record by its creation timestamp.

**Better approach:** Use range queries or dedicated ID fields for lookups:

```sql
-- Instead of exact equality
SELECT * FROM orders 
WHERE created_at BETWEEN $1 - INTERVAL '1 millisecond' 
                    AND $1 + INTERVAL '1 millisecond'

-- Or better: use a proper unique constraint
SELECT * FROM orders WHERE idempotency_key = $1
```

## Storing Context Separately

Sometimes the moment something happened isn't enough—you need to know the user's context when it happened. A few scenarios:

**Logging user actions:** Store when they did it (`TIMESTAMPTZ`), but also store what timezone their browser reported (`TEXT` column). This helps debug issues like "why did these two events look out of order to the user?"

**Scheduling across timezones:** Store the target moment (`TIMESTAMPTZ`), but also store which timezone the schedule was created in (`TEXT` column). When displaying "your meeting is at 3:00 PM," you convert the absolute time back to their timezone.

**Audit trails:** Store when the change happened server-side (`TIMESTAMPTZ`), potentially the client timestamp they sent (`TIMESTAMPTZ`), and the clock skew between them (`INTERVAL`). Helps identify clients with incorrect system clocks.

## Practical Guidelines

**Default to TIMESTAMPTZ.** Unless you have a specific reason not to, use `TIMESTAMPTZ` for any timestamp column. It's the same storage size and performance as `TIMESTAMP`, but it handles multi-region deployments and daylight saving time correctly.

**Set server timezone to UTC.** Every server writing timestamps should use UTC. This eliminates an entire class of bugs around daylight saving time transitions and regional differences.

**Require timezone info from clients.** Reject date strings like `2025-01-01T10:00:00`. Require ISO-8601 format with an offset: `2025-01-01T10:00:00Z` or `2025-01-01T10:00:00-05:00`. Don't guess what the client meant.

**Set session timezone explicitly.** Most Postgres drivers let you configure this, but you have to actually do it. A `SET TIME ZONE 'UTC';` at the start of each connection, or configuring your connection pool to do it automatically based on your needs.

**Consider separate columns for different concerns.** If you need both "when it happened" and "what timezone the user was in," those are two different pieces of information. Store them separately.

## Example Schema Patterns

```sql
-- Event tracking: just need the absolute moment
CREATE TABLE user_actions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,
  action TEXT NOT NULL,
  occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Scheduling: need both moment and display timezone
CREATE TABLE scheduled_tasks (
  id SERIAL PRIMARY KEY,
  task_name TEXT NOT NULL,
  scheduled_for TIMESTAMPTZ NOT NULL,
  timezone TEXT NOT NULL,  -- e.g., 'America/New_York'
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Audit trail: capture multiple time perspectives
CREATE TABLE audit_log (
  id SERIAL PRIMARY KEY,
  entity_id INTEGER NOT NULL,
  server_timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  client_timestamp TIMESTAMPTZ,
  client_timezone TEXT,
  clock_skew INTERVAL GENERATED ALWAYS AS (server_timestamp - client_timestamp) STORED
);

-- Recurring schedule: wall-clock time
CREATE TABLE recurring_events (
  id SERIAL PRIMARY KEY,
  event_name TEXT NOT NULL,
  recurrence_time TIME NOT NULL,  -- Just the time: 14:00:00
  timezone TEXT NOT NULL,
  next_occurrence TIMESTAMPTZ  -- Computed: next actual moment this will run
);
```

## A Word on Enforcement

If you decide `TIMESTAMPTZ` is your default (which it should be for most apps), consider enforcing it. A database trigger that rejects `TIMESTAMP WITHOUT TIME ZONE` columns sounds extreme, but it prevents the "oops, forgot to specify TZ" bug that otherwise shows up months later:

```sql
CREATE OR REPLACE FUNCTION check_timestamp_tz()
RETURNS event_trigger AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM pg_attribute a
    JOIN pg_class c ON a.attrelid = c.oid
    WHERE a.atttypid = 'timestamp'::regtype
  ) THEN
    RAISE EXCEPTION 'Use TIMESTAMPTZ instead of TIMESTAMP';
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER enforce_timestamptz 
ON ddl_command_end 
WHEN TAG IN ('CREATE TABLE', 'ALTER TABLE')
EXECUTE FUNCTION check_timestamp_tz();
```

## The Real Lesson

Time in databases isn't hard because timestamps are complicated. It's hard because we often don't stop to ask what we're actually trying to record. "When did this happen?" is different from "what time should we do this?" which is different from "what did the clock say when the user did this?"

Think about your requirements first. Then pick the timestamp type (and any additional context columns) that actually answer your question. Most of the time, that's `TIMESTAMPTZ` and UTC everywhere. But when it's not, you'll know why.

## Resources

- [PostgreSQL Date/Time Types Documentation](https://www.postgresql.org/docs/current/datatype-datetime.html)
- [PostgreSQL Timestamp Best Practices](https://wiki.postgresql.org/wiki/Don%27t_Do_This#Date.2FTime_storage)
- [ISO 8601 Date and Time Format](https://en.wikipedia.org/wiki/ISO_8601)
- [Time Zone Database (IANA)](https://www.iana.org/time-zones)
- [Dealing with Timestamps in Distributed Systems](https://www.postgresql.org/docs/current/functions-datetime.html)

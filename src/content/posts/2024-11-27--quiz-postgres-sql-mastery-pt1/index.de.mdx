---
language_name: German
title: "Quiz: Deep Postgres: Pt. 1"
subTitle: "Macht SQL Sie schreien?"
unlisted: false
social_image: mobile.webp
label: "Deep PostgreSQL #1"
category: Quiz
subCategory: Database
date: 2024-11-27
modified: 2024-12-03
tags: [quiz, postgresql, sql, database, intermediate, advanced]
cover_full_width: elephant-synthwave-gym-wide.webp
cover_mobile: elephant-synthwave-gym-square.webp
cover_icon: elephant-synthwave-gym-square.webp
---

import Challenge from '../../../components/QuizUI/Challenge';
import QuizUI from '../../../components/QuizUI/QuizUI';

> **Teil 1 von 2.** [Gehe zu Teil 2](/quiz-postgres-sql-mastery-pt2/)

<p class="inset">PostgreSQL üêò Ist mein liebster Datenbank-Service! Ich lerne immer wieder neue Tricks und Kniffe, also habe ich mich entschieden, sie in einem neuen Quiz zu testen!</p>

Dieses Quiz befasst sich mit einem Mix aus bekannten und weniger bekannten PostgreSQL-Funktionen und Kuriosit√§ten: von integrierten Aggregaten √ºber Typumwandlung, Constraints und mehr.

Viel Gl√ºck! üçÄ

<QuizUI>

<Challenge
  client:load
  index={0}
  group="Warmup: Functions"
  title="Built-in Aggregates"
  options={[
    {text: 'MIN'},
    {text: 'MAX'},
    {text: 'AVG'},
    {text: 'MEDIAN', isAnswer: true}
  ]}
>
  <slot name="question">
  <div className="question">
    Welches ist KEINE integrierte Aggregatfunktion in PostgreSQL?
    ```sql
    SELECT 
      MIN(grade) as lowest,
      MAX(grade) as highest,
      AVG(grade) as average,
      MEDIAN(grade) as middle
    FROM grades;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `MEDIAN` ist keine integrierte Funktion! Man ben√∂tigt:
    ```sql
    PERCENTILE_CONT(0.5) 
    WITHIN GROUP (ORDER BY grade)
    ```

    H√§ufig genutzte integrierte Aggregatfunktionen:
    - `MIN`, `MAX`, `COUNT`
    - `AVG`, `SUM`
    - `ARRAY_AGG`, `STRING_AGG`
    - Verschiedene statistische Funktionen
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={1}
  group="Warmup: Type Casting"
  title="Cast Syntax Variations"
  options={[
    {text: `'95'::INTEGER`},
    {text: `INTEGER '95'`},
    {text: `CAST('95', INTEGER)`, isAnswer: true},
    {text: `CAST('95' AS INTEGER)`},
  ]}
>
  <slot name="question">
  <div className="question">
    Welche dieser Typumwandlungen ist **nicht** g√ºltig ‚ùå?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL unterst√ºtzt drei Casting-Syntaxe:

    1. ANSI SQL: `CAST(expression AS type)`.
    2. PostgreSQL: `expression::type`.
    3. Typfunktion: `type 'literal'`.

    Alle sind funktional gleichwertig, aber:
    - `CAST()` ist am besten f√ºr Portabilit√§t.
    - `::` ist spezifisch f√ºr PostgreSQL, aber h√§ufig verwendet.
    - Infix-Style `type 'literal'` ist weniger gebr√§uchlich, aber immer noch g√ºltig.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Constraints"
  title="UNIQUE Constraints and NULL"
  options={[
    {text: 'No NULLs allowed'},
    {text: 'One NULL allowed', },
    {text: 'Two NULLs allowed', isAnswer: true},
    {text: 'Depends on PostgreSQL version'},
  ]}
>
  <slot name="question">
  <div className="question">
    Wie viele `NULL`-Werte sind hier erlaubt?
    ```sql
    CREATE TABLE student_emails (
      student_id INTEGER,
      email VARCHAR(255),
      UNIQUE(email)
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `UNIQUE` Constraints in PostgreSQL:
    - Erlauben mehrere NULL-Werte.
    - `NULL` ‚â† `NULL` in Verbindung mit Eindeutigkeit.

    Um `NULL`-Werte zu verhindern, f√ºgen Sie `NOT NULL` hinzu:
    ```sql
    CREATE TABLE student_emails (
      student_id INTEGER,
      email VARCHAR(255) NOT NULL,
      UNIQUE(email)
    );
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={3}
  group="Date/Time"
  title="Date Arithmetic"
  options={[
    {text: '2024-11-27'},
    {text: '2024-11-27 00:00:00'},
    {text: '2024-11-28'},
    {text: '2024-11-28 00:00:00', isAnswer: true},
    {text: 'Error: invalid time'},
  ]}
>
  <slot name="question">
  <div className="question">
    Was liefert diese Abfrage?
    ```sql
    SELECT '2024-11-27'::date + interval '24 hours';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Intervalle sind eine m√§chtige M√∂glichkeit, um Datumsbereiche zu verwalten!

    Datumsmathematik in PostgreSQL:
    - `+ interval '24 hours'` f√ºgt 24 Stunden hinzu
    - `+ interval '1 day'` f√ºgt einen Tag hinzu
    - `+ interval '1 month'` f√ºgt einen Monat hinzu
    - `+ interval '1 year'` f√ºgt ein Jahr hinzu

    Das Ergebnis ist `2024-11-28 00:00:00`.
  </div>
  </slot>
</Challenge>

# Verwirrende Typen

Ich bin mir sicher, dass Sie *so viele* Typen in PostgreSQL verwendet haben, oder?

Die folgenden Fragen beziehen sich auf die native Typen von Postgres v17. ü§Ø

F√ºr jede Frage identifizieren Sie das **ung√ºltige Type**. üïµÔ∏è‚Äç‚ôÇÔ∏è

<p class="inset">Los geht's!</p>

<Challenge
  client:load
  index={5}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'VARCHAR(100)'},
    {text: 'CHAR(100)'},
    {text: 'TEXT'},
    {text: 'STRING(100)', isAnswer: true},
    {text: 'CHARACTER VARYING(100)'},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL verf√ºgt √ºber eine reiche Sammlung von Datentypen, aber `STRING(100)` ist einer von ihnen.

    Die korrekten Zeichentypen umfassen:
    - `VARCHAR(100)` (variabler L√§ngenstring)
    - `CHAR(100)` (festgelegte L√§nge String)
    - `TEXT` (unbegrenzte L√§nge)
    - `CHARACTER VARYING(100)` (gleich `VARCHAR(100)`)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={6}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'int'},
    {text: 'real'},
    {text: 'bigint'},
    {text: 'bigserial'},
    {text: 'smallserial'},
    {text: 'decimal128', isAnswer: true},
    {text: 'double precision'},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Es mag vertraut erscheinen, da `decimal128` ein Typ in vielen Orten (einschlie√ülich Mongo und Java) ist. Das ist es nicht.

    Die korrekten numerischen Typen umfassen:
    - `int` (4-byte Integer)
    - `bigint` (8-byte Integer)
    - `real` (4-byte Flie√ükommazahl)
    - `double precision` (8-byte Flie√ükommazahl)
    - `bigserial` (inkrementierender 8-byte Integer)
    - `smallserial` (inkrementierender 2-byte Integer)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={7}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'cidr'},
    {text: 'inet'},
    {text: 'ipv4', isAnswer: true},
    {text: 'macaddr'},
    {text: 'macaddr8'},
    {text: 'interval'},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL verf√ºgt √ºber eine reiche Sammlung von Netzwerktypen, aber `ipv4` geh√∂rt dazu nicht.

    Die korrekten Netzwerktypen umfassen:
    - `cidr` (IPv4/IPv6 Netzwerkadresse)
    - `inet` (IPv4/IPv6 Host-Adresse)
    - `ipv4` (IPv4 Host-Adresse)
    - `macaddr` (MAC-Adresse)
    - `macaddr8` (EUI-64 MAC-Adresse)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={8}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'xml'},
    {text: 'uuid'},
    {text: 'money'},
    {text: 'currency', isAnswer: true},
    {text: 'interval'},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL verf√ºgt √ºber eine reiche Sammlung von spezialisierten Typen, aber `triangle` geh√∂rt dazu nicht.

    Die korrekten specialisierten Typen umfassen:
    - `xml` (XML-Daten)
    - `uuid` (UUID)
    - `money` (W√§hrungsbetrag)
    - `interval` (Zeitintervall)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'box'},
    {text: 'line'},
    {text: 'point'},
    {text: 'circle'},
    {text: 'polygon'},
    {text: 'triangle', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL verf√ºgt √ºber eine reiche Sammlung von spezialisierten Typen, aber `triangle` geh√∂rt dazu nicht.

    Die korrekten specialisierten Typen umfassen:
    - `box` (rechteckiger Bereich)
    - `line` (unendliche Linie)
    - `point` (2D-Punkt)
    - `circle` (2D-Kreis)
    - `polygon` (2D-Vielkant)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={10}
  group="Integer Arithmetic"
  title="Integer Overflow"
  options={[
    {text: '4294967296'},
    {text: 'Error: integer out of range', isAnswer: true},
    {text: '0'},
    {text: '2147483647'},
  ]}
>
  <slot name="question">
  <div className="question">
    Was passiert, wenn man die m√∂glichen Studenten-IDs berechnet?
    ```sql
    SELECT 256 * 256 * 256 * 256;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Postgres' `integer` Typ ist 32-Bit signiert, mit einem Bereich von `-2.147.483.648` bis `2.147.483.647`.

    Die Berechnung `256^4` √ºberschreitet diesen Bereich.

    Um gr√∂√üere Zahlen zu handhaben:
    ```sql
    -- Verwenden Sie BIGINT
    SELECT 256::bigint * 256 * 256 * 256;

    -- Oder numerisch f√ºr beliebige Genauigkeit
    SELECT 256::numeric * 256 * 256 * 256;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={11}
  group="Date/Time"
  title="Timestamp Precision"
  options={[
    {text: '2024-01-08 13:30:00+00'},
    {text: '2024-01-08 13:30:00.123456+00'},
    {text: '2024-01-08 13:30:00.123456789+00'},
    {text: '2024-01-08 13:30:00.1234567', isAnswer: true}
  ]}
>
  <slot name="question">
  <div className="question">
    Welches ist die kleinste `timestamp`-Literal, das den maximalen `time`-Genauigkeit in Postgres √ºbersteigt?
    ```sql
    CREATE TABLE class_sessions (
      id INT GENERATED BY DEFAULT AS IDENTITY,
      start_time timestamptz,
      end_time timestamptz
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL-Timestamps haben eine Mikrosekunden-Precison (6 Dezimalstellen).

    - Maximale Werte: `.123456` (6 Ziffern)
    - Nanosekunden (9 Ziffern) werden abgeschnitten
    - Zeitzone-Umfang ist f√ºr `timestamptz` erforderlich

    **Nicht-so-gemeines-H√§ufiges-Verhaltensweisen:** Einige Sprachen/Frameworks senden Pr√§zision in Nanosekunden, die anonym abgeschnitten werden!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={12}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'lseg'},
    {text: 'bytea'},
    {text: 'tsquery'},
    {text: 'tsvector'},
    {text: 'tsrank', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Welches dieser ist **nicht** ‚ùå ein g√ºltiger PostgreSQL-Typ?

    (Ehrlich gesagt sind das (fast) alle echten Typen.)
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL verf√ºgt √ºber mehrere eingebaute geometrische und textbasierte Suchtypen, aber `tsrank` geh√∂rt dazu nicht.

    Die korrekten geometrischen und textbasierenden Typen umfassen:
    - `lseg` (Linienabschnitt)
    - `txid` (Transaktions-ID)
    - `bytea` (bin√§re Daten)
    - `tsquery` (Textsuchabfrage)
    - `tsvector` (textbasiertes Dokument)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={13}
  group="Constraints"
  title="Check Constraint Timing"
  options={[
    {text: 'Immediately'},
    {text: 'At transaction commit', isAnswer: true},
    {text: 'On next query'},
    {text: 'Never - constraints are only checked on INSERT'}
  ]}
>
  <slot name="question">
  <div className="question">
    Wenn ist diese Grade-Beschr√§nkung gepr√ºft?
    ```sql
    ALTER TABLE students 
    ADD CONSTRAINT valid_grade 
    CHECK (
      (grade >= 0 AND grade <= 100) OR 
      grade IS NULL
    ) NOT VALID;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `NOT VALID` Constraints:
    - Werden bei der Transaktionscommitt gepr√ºft
    - Validierung bestehender Zeilen wird nicht durchgef√ºhrt
    - N√ºtzlich f√ºr gro√üe Tabellen

    Ohne `NOT VALID`:
    - Die Beschr√§nkung wird sofort gepr√ºft
    - Alle bestehenden Zeilen werden validiert
    - Kann bei gro√üen Tabellen langsam sein
  </div>
  </slot>
</Challenge>

</QuizUI>

Gut gemacht! Sie sind tief in verschiedene Bereiche von PostgreSQL eingetaucht! üêò

Ich hoffe, Sie haben etwas Neues gelernt oder zumindest einen Score, √ºber den man braten kann! üèÜ

<p class="inset">Schauen Sie sich [Teil 2](/quiz-postgres-sql-mastery-pt2/) an, um mehr Postgres-Abenteuer zu genie√üen! üöÄ</p>

M√∂chten Sie mehr Spannung im Leben haben? Schauen Sie in meiner [Quiz-Sammlung](/challenges/) f√ºr endlose* Spa√ü!



{/* Translated from English to German
Original text length: 14001 characters
Translation API: http://192.168.0.87:1234/v1/chat/completions
Translation model: NousResearch/Hermes-3-Llama-3.1-8B-GGUF
Translation date: 2024-12-06T10:13:53.140Z */}

--- 
title: Один странный трюк для ускорения команд по функциям!
subTitle: Инженеры-штатники ненавидят это!
date: 2024-09-29
modified: 2024-09-30
tags: [агиль, команды]
category: Инженерия

cover_full_width: ../../2024-09-29--one-weird-trick-to-speed-up-feature-teams/wide_danny-howe-98KlbUsOO_w-unsplash.webp
cover: ../../2024-09-29--one-weird-trick-to-speed-up-feature-teams/danny-howe-98KlbUsOO_w-unsplash__w300.webp
cover_mobile: ../../2024-09-29--one-weird-trick-to-speed-up-feature-teams/danny-howe-98KlbUsOO_w-unsplash__w200.webp
cover_icon: ../../2024-09-29--one-weird-trick-to-speed-up-feature-teams/danny-howe-98KlbUsOO_w-unsplash__w200.webp
cover_credit: Фото <a href="https://unsplash.com/@dannyhowe?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Дэнни Хоу</a> на <a href="https://unsplash.com/photos/red-and-white-neon-light-signage-98KlbUsOO_w?utm_content=creditCopyText&utm_medium=referral&utm_source=unsplash">Unsplash</a>

---

<details>
<summary>Содержание</summary>

- [Думая в ключи](#thinking-in-keys)
  - [Проектирование с ключами](#designing-with-keys)
  - [КВ как графики и деревья?](#kvs-as-graphs--trees)
  - [Когда использовать шаблоны КВ](#when-to-use-kv-patterns)
  - [Когда избегать шаблонов КВ](#when-to-avoid-kv-patterns)
  - [Когда вам понадобится больше, чем КВ](#when-you-need-more-than-kv)
- [Дальнейшие действия](#next-steps)
  - [Служба фактов - проект-отсчетчик](#fact-service---reference-project)
- [Заключение](#conclusion)
  - [Дополнительная литература](#further-reading)

</details>

Когда проектируете новую систему или функцию, легко застрять на проектировании схемы данных. В этой статье я поделюсь полезным трюком, который принес пользу в моей карьере.

<section class="breakout">
_Попробуйте_ использовать простейшую возможную сохранение данных при проектировании новой системы или функции.
</section>

Всегда слишком часто я видел команды, которые выбирают SQL или MongoDB как единственный вариант для хранения данных. Да, никто не будет уволен за выбор SQL. Но что если я скажу вам, что существует более простое, быстрее и дешевле способ начать?

Хранение ключ-значение (KV) может быть все, что вам нужно. Например, Redis или S3.

Это не всегда правильный выбор, но, возможно, **более часто, чем вы думаете**.

Простой слой хранения данных может умеренно ускорить **ранний** разработку за счет повторного использования кода слоя данных и избежания затрат, связанных с изменением схемы данных и миграциями. Изменения все равно произойдут; пусть код будет заботиться о них как можно дольше. Лучше избегать изменения в двух местах.

Получаемые преимущества скорости, вероятно, поскольку `ключ` поиски оптимизированы и записи могут получить выгоду от групповых обновлений.

{/* Avoid KV patterns if you need JOINs or to query by properties in your dataset. Or in cases where you have an unbounded/infinitely growing datasets. (`Logs`, `Signups`, etc.) */}

## Думая в ключи

Может показаться странным проектировать с шаблоном КВ первым, особенно если вы привыкли проектировать системы с иерархиями объектов или диаграммами отношений и напрямую реализовать их в SQL.

Вы, возможно, ***использовали*** шаблоны ключ-значение раньше! Они повсюду: от конфигураций и URL до хранилища S3-стиля! Каждый раз, когда вы работаете с данными через уникальный `ID` значение, guess what? Другой шаблон КВ! (Хотя не обязательно KV Хранение.)

### Проектирование с ключами

Практически все данные _могут_ быть представлены с помощью шаблонов КВ. (На самом деле, многие более высокоуровневые БД строятся на нижележащих шаблонах КВ.) Давайте посмотрим на некоторые примеры:

```markdown
user/123          {id: 123, ...}
user/123/block    ['user/456', 'user/789']
user/123/groups   ['admin', 'staff']
user/420/friends  ['user/456', 'user/789']

group/admin       {user: '*:rw'}
group/default     {user: '*:r'}

product/42/discount/<UUID>	{percentOff: '10%'}
product/42/discount/<UUID>	{percentOff: '20%', minTotal: 100.0}
```

Вы, возможно, заметили, но `ID` часто является ключом в себе! Это распространенный шаблон в хранилищах КВ. Ключ часто представляет собой комбинацию типа сущности и уникального идентификатора. (например `user/123`, `user:456`)

### КВ как графики и деревья?

Может быть полезно представлять сложные структуры данных, такие как Графы или Деревья, с помощью шаблонов КВ. (Опять же, URL REST являются отличным примером этого.)

Иерархия ключей (`user/420` -> `user/420/friends`) естественным образом кодирует связь графа между `user` и их `friends`.

Это быстрый и дешевый способ сериализировать структуры данных графа. Особенно если у вас нет необходимости в сложности базы данных графа (как Neo4j).

<figure>
![Граф user/123](./KVsCanBeGraphs.webp)
<figcaption>Граф user/123</figcaption>
</figure>

### Когда использовать шаблоны КВ

- Когда вам нужно масштабировать до миллиардов или даже триллионов пар КВ.
- Когда вы преимущественно доступаете данные через уникальный ключ.
- Когда вам нужна простая структура данных.
- Когда у вас есть данные с иерархической, графовой или деревянистой структурой.

### Когда избегать шаблонов КВ

Не храните вещи, такие как комментарии блога в _**одном**_ паре КВ. Например, `post/666 -> {comments: [...too many...]}`. Вместо этого вы можете использовать `post/666/comments/1`, или `post/666/comments/<UUID>`, и т. д. Или переходите на SQL.

- Когда вам нужно искать по свойствам (не ключу или ID) в вашем наборе данных.
- Когда вам нужно объединять данные через несколько сущностей.
- Когда у вас есть неограниченные/бесконечные наборы данных. (`Логи`, `Регистрации`, и т. д.)

### Когда вам понадобится больше, чем КВ

По мере естественного развития проектных требований может потребоваться сделать больше, чем поддерживает ваше хранение КВ. В этом случае вы должны будете посмотреть на миграцию в более сложную базу данных.

{/* The good news is that you can often start with a KV pattern and evolve it into a more complex system as needed. S3 has features beyond simple storage, from Athena for searching files, Glacier, and Expire policies there's a lot you can do with it. Also, Redis has added many high-level features (like Pub/Sub, Geo-spatial, Streams, and Sorted Sets) that can help you meet some requirements. */}

Хорошая новость в том, что миграцию одного хранилища КВ на SQL относительно легче, чем миграцию сложной схемы SQL в хранение КВ. (С несколькими таблицами, индексами, ограничениями и т. д.) Я делал это много раз с 50-строчным скриптом.

Аналогично, я обнаружил, что качество проектирования SQL выше, если вы начинаете с шаблона КВ первым. Это заставляет вас действительно подумать о данных по-другому и лучше понять _точно_ то, что вам нужно от SQL.

## Дальнейшие действия

Лучший способ учиться — пробовать! Если вы заинтересованы в изучении этого шаблона дальше, я рекомендую **строить вещи** с Redis, DynamoDB или S3.
Все они отличные хранилища КВ с разными trade-offs.

### Служба фактов - проект-отсчетчик

Проверьте мой Открытый исходный код ["Службу Фактов", проект-отсчетчик на GitHub](https://github.com/justsml/fact-service).

Это отдельная RESTful API, реализующая сервис хранения данных КВ.

Она включает в себя многие [адаптеры данных](https://github.com/justsml/fact-service/tree/main/lib/providers).
Включая для Postgres, Redis, DynamoDB, Firestore и Cassandra! (С полными командами Docker для быстрого старта.)

Служба фактов предназначена для использования в качестве стартового проекта и обучения, fork ее и создайте свой собственный сервис хранения данных КВ!

## Заключение

Я надеюсь, что эта статья была полезной! Если у вас есть вопросы или отзывы, пожалуйста, не стесняйтесь комментировать или `@` меня на [Twitter](https://twitter.com/justsml).

### Кредиты

- [Моделирование иерархических деревьев данных в PostgreSQL](https://leonardqmarcq.com/posts/modeling-hierarchical-tree-data)
- [Делайте и не делайте хранения больших деревьев в PostgreSQL](https://leonardqmarcq.com/posts/dos-and-donts-of-modeling-hierarchical-trees-in-postgres)

### Дополнительная литература

- [Служба фактов](https://github.com/justsml/fact-service)
- [Postgres](https://www.postgresql.org/)
- [Redis](https://redis.io/)
- [DynamoDB](https://aws.amazon.com/dynamodb/)
- [S3](https://aws.amazon.com/s3/)
- [Cassandra](https://cassandra.apache.org/)
- [Firestore](https://firebase.google.com/docs/firestore)

{/* <!-- Translated from English to Russian -->
<!-- Original text length: 7729 characters -->
<!-- Translated text length: 8108 characters -->
<!-- Translation API: http://localhost:1234/v1/chat/completions -->
<!-- Translation model: lmstudio-community/Meta-Llama-3.1-8B-Instruct-GGUF -->
<!-- Translation date: 2024-11-26T19:45:40.904Z --> */}

---
title: "Essential Docker Security Tips for Self-Hosting"
subTitle: "Tips for securing your Self-hosted Docker services - from network security to monitoring!"
date: 2025-01-04
modified: 2025-01-06
tags: [docker, security, devops, containers, best-practices]
category: Security

social_image: desktop-social.webp
cover_full_width: docker-ukiyo-e-wide.webp
cover_mobile: docker-ukiyo-e-container-square-200.webp
cover_icon: docker-ukiyo-e-container-square-200.webp
cover_credit: ¬© 2025 Dan Levy
---

import {CodeTabs} from '../../../components/CodeTabs';

**Table of Contents**

- üßó‚Äç‚ôÄÔ∏è [For the brave](#-for-the-brave)
- üîÑ [The `:latest` Dance](#-the-latest-dance)
- üîê [Secrets Management: The Right Way](#-secrets-management)
- üåê [Network Hazard](#-network-hazard)
- üõ°Ô∏è [Access Controls](#-access-controls)
- üîç [Monitoring & Verification](#-monitoring--verification)
- ‚è∞ [Parting Thoughts](#-parting-thoughts)
- üöÄ [Production Checklist](#-production-checklist)
- üìö [Further Reading](#-further-reading)
- üôè [Thanks](#thanks)


## üßó‚Äç‚ôÄÔ∏è For the brave

If you‚Äôre self-hosting Docker services, security is your responsibility from top to bottom‚Äîno cloud provider to shield you from port scans or sloppy config. Whether you‚Äôre spinning up apps on your home network or renting VPSes from providers like Vultr, DigitalOcean, Linode, AWS, Azure, or Google Cloud, you‚Äôll need to lock things down - and verify you did it right.

In this guide, we‚Äôll walk through Docker security essentials‚Äîcovering canary tokens, read-only volumes, firewall rules, network segmentation, and everything in between. We‚Äôll also compare home networks to public cloud setups and show you how to set up a basic auth proxy with Nginx. By the end, you‚Äôll have several options to keep out the riff-raff (friends, family, or your own suspicious self).

Let‚Äôs dive in!

---

## üîÑ The `:latest` Dance

Keeping images updated is crucial for security. However, relying blindly on `:latest` can lead to breaking changes or vulnerabilities creeping in unnoticed.

### The Safe Way to Update

```bash
#!/bin/bash
# update-and-run.sh
docker compose pull && \
docker compose down && \
docker compose up -d
```

### Version Pinning vs Latest

```yaml
# docker-compose.yml
# ...
  # Exact version pinning, best for critical services
  image: postgres:17.2.1

  # Patch version pinning, good for non-critical services
  image: postgres:17.2

  # Major version pinning, perfect for hobby projects
  image: postgres:17

  # Yolo, avoid if possible
  image: postgres:latest
```

Use [Dependabot](https://github.com/features/security) or [Renovate](https://github.com/renovatebot/renovate) to automate version updates and ensure you‚Äôre reviewing changes before they break production.

_Let me know about your favorite tools for keeping Docker images up-to-date!_

## üîê Secrets Management

Never bake your secrets (API tokens, passwords, keys) into Docker images **_OR_** commit them to git.

Keep secrets out of your repos & containers - and rotate them periodically!

### Generate Strong Secrets

```bash
#!/bin/bash
# generate-secrets.sh

generate_secret() {
    local length=${1:-30}
    local generate_length=$((length + 4))
    openssl rand -base64 "$generate_length" | tr -d '+=/\n' | cut -c1-"$length"
}

[ -f .env ] && { echo ".env file already exists!"; exit 1; }

cat > .env << EOL
POSTGRES_PASSWORD=$(generate_secret)
JWT_SECRET=$(generate_secret 64)
SESSION_KEY=$(generate_secret 24)
REDIS_PASSWORD=$(generate_secret 20)
UNSAFE_PLACEHOLDER=__WARNING_REPLACE_RANDOM_TEXT__
EOL

echo "New .env file generated with secure random values!"
```


### Defensive Placeholder Validation

<blockquote>You wouldn't believe how easy it is to hack a JWT token when the secret isn't secret!</blockquote>

<p className='inset'>üí° Ensure secrets are always unique. Try make it impossible to run with unsafe/hard-coded defaults.</p>

If you use placeholders like `__WARNING_REPLACE_ME__` in your secrets, great, maybe someone will notice!

Just in case, you can also add a little runtime safety with little effort. Here‚Äôs how you might do it in JavaScript, Rust, and Go:

<CodeTabs client:load tabs={["JavaScript", "Rust", "Go"]}>

```javascript
// validateSecrets.js
const validateSecrets = () => {
  const unsafePlaceholder = /__WARNING_REPLACE_ME__/;
  const missingSecrets = Object.entries(process.env).filter(
    ([key, value]) => unsafePlaceholder.test(value)
  );

  if (missingSecrets.length) {
    console.error("Unsafe secrets detected:", missingSecrets);
    process.exit(1);
  }
};

validateSecrets();
```

```rust
// validate_secrets.rs
use std::env;

fn validate_secrets() {
    let unsafe_placeholder = "__WARNING_REPLACE_ME__";
    for (key, value) in env::vars() {
        if value.contains(unsafe_placeholder) {
            panic!("Unsafe secret in {}", key);
        }
    }
}

fn main() {
    validate_secrets();
}
```

```go
// validate_secrets.go
package main

import (
	"fmt"
	"os"
	"strings"
)

func validateSecrets() {
	placeholder := "__WARNING_REPLACE_ME__"
	for _, env := range os.Environ() {
		pair := strings.SplitN(env, "=", 2)
		if len(pair) == 2 && strings.Contains(pair[1], placeholder) {
			panic(fmt.Sprintf("Unsafe secret in %s", pair[0]))
		}
	}
}

func main() {
	validateSecrets()
}
```

</CodeTabs>

## üåê Network Hazard

### Custom Networks & Internal Ports

```yaml
networks:
  backend:
    internal: true  # No external traffic allowed

services:
  webapp:
    networks:
      - backend
    ports:
      - "127.0.0.1:8080:8080" # Expose locally only
  database:
    networks:
      - backend
    # No published ports, only accessible inside backend network
```

Properly isolating services with Docker networks can reduce your attack surface. Services on a private or ‚Äúinternal‚Äù network won‚Äôt be accessible from the public internet.

### Docker Socket Access

#### ‚ö†Ô∏è Warning: `docker.socket` is extremely powerful and dangerous dark magic!

<blockquote class="inset">‚ö†Ô∏è The \`:ro\` option doesn't affect I/O sent over the socket!</blockquote>

It merely ensures the file (a Unix socket, not a file in the traditional sense) itself is `read-only`.

{/* Any process that can "open" the socket can (probably) gain root access on the host. */}

#### Socket Best Practice

- ü•á **Never do it!**
- ü´£ If you must, **use a Reverse Proxy** to limit what API commands are available. Check out Tecnativa's [docker-socket-proxy](https://github.com/Tecnativa/docker-socket-proxy).
- ü§¢ Okay, _maybe_ in a very **high-trust**, **low-risk** environment.

Access to the Docker socket (`/var/run/docker.sock`) tends to lead to total root access. Be careful!

## üõ°Ô∏è Access Controls

When it comes to limiting access to your services, many methods might seem effective but often fall short in practice.

Let's take a look at some common pitfalls and best practices for limiting access to your Docker services.

### Docker on Ubuntu

A very popular setup, with 2 very common pitfalls:

> ‚ö†Ô∏è **Warning #1:** By default [Docker on Ubuntu/Debian will bypass UFW](https://github.com/moby/moby/issues/777)/iptables rules, rendering **your firewall useless.**
> ‚ö†Ô∏è **Warning #2:** Binding ports to local IP addresses (e.g. `-p 127.0.0.1:8080:80`) may only offer limited protection as well. See also [issue: #690 - Docker bypasses ufw firewall rules](https://github.com/docker/for-linux/issues/690)

<p class="inset">This surprises me every time I run right into it. üòÖ</p>

So, instead of thinking of your firewall as your primary defense, embrace Docker Networks. They provide **isolation** and **segmentation** at the network layer - without requiring everyone become a master at `iptables`.

### Network Best Practice

1. ü•á **Use Docker Networks** to isolate and control which containers can talk to each other.
2. ü•â If you really must use containers on a `host` or `bridge` network, you can get UFW and iptables to work with most docker setups. I recommend checking out this utility to make life easier: [ufw-docker](https://github.com/chaifeng/ufw-docker).

#### Docker Network Isolation

```bash
# Create a new Docker network
docker network create db-network

docker run -d --name postgres \
 -e POSTGRES_PASSWORD=${POSTGRES_PASSWORD} \
 -e POSTGRES_USER=${POSTGRES_USER} \
 -e POSTGRES_DB=${POSTGRES_DB} \
 --network db-network \
 postgres:17.1

docker run -d --name pg-admin \
 -p 8081:80 \
 -e PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL} \
 -e PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD} \
 --network db-network \
 dpage/pgadmin4:4.1
```

Here's an (abbreviated) example `docker-compose.yml` using a shared network, `db-network`:

```yaml
services:
  webapp:
    build: .
    ports:
      - "8080:80"
    networks: [ db-network ]
  database:
    image: postgres:17.1
    networks: [ db-network ]
    # ... other settings
  db-admin:
    image: dpage/pgadmin4:4.1
    networks: [ db-network, auto-net ]
    # ... other settings
    ports:
      - "8081:80"

networks:
  db-network:
    external: true # created with `docker network create db-network`
  auto-net: # auto-created network
```

Now your services can communicate with each other via the `db-network` network. The `auto-net` network will be created automatically by Docker Compose.

Use the `--external` flag to join a **pre-existing network.** Ommitting it will create a new network.

#### Blocking Country!

Another decent idea!

_Talking about the geopolitical entity, not the music..._

If you are hosting apps mostly for your local family & friends, you can block traffic from countries you don't expect to receive traffic from. Or only allow traffic from countries you do expect.

Check out this script to block all traffic from China:

```bash title="block-china.sh"
wget -O- https://www.ipdeny.com/ipblocks/data/countries/cn.zone | \
  while read line; do ufw deny from $line to any; done
```

#### Hardening CloudFlare Proxy Host

If your home server is protected behind a CloudFlare IP (proxy,) you can restrict access to only CloudFlare IPs and your local subnet.

This is a little similar to Country blocking above, but with much tighter control.

```bash title="whitelist-ingress-from-cloudflare.sh"
ufw default deny incoming # Block all incoming!!!
ufw default allow outgoing # Allow all outgoing
ufw allow ssh # Allow SSH

# Allow access for local subnet (preferably dedicated subnet for hosted services)
ufw allow from 10.0.0.0/8 to any port 443

# Allow CloudFlare IPs
wget -O- https://www.cloudflare.com/ips-v4 | \
  while read line; do ufw allow from $line to any port 443; done
# Add IPv6 support
# wget -O- https://www.cloudflare.com/ips-v6 | \
  # while read line; do ufw allow from $line to any port 443; done
```

### Protecting Access

Once your network and host are security hardened. We need to worry about the services themselves. Do they all automate HTTPS with Let's Encrypt? Do they have built-in auth?

Since many self-hosted projects were not designed to be exposed to the internet, with default user credentials, or wide open signup pages, it can lead to a disaster.

#### Reverse Proxy

Another layer of defense is basic auth. I know it's dangerous to use without HTTPS, but sometimes it's the best you can do, and it's often enough to stop automated Cross-Site-Request-Forgery attacks.

```nginx
# /etc/nginx/conf.d/secure-admin.conf
location /admin {
    auth_basic "Restricted Access";
    auth_basic_user_file /etc/nginx/.htpasswd;
    proxy_pass http://internal_admin:80;
    proxy_set_header X-Real-IP $remote_addr;
}
```

Generate credentials:

```bash
htpasswd -c /etc/nginx/.htpasswd admin
```

With a basic auth proxy, attackers have an extra hurdle‚Äîusername and password‚Äîbefore hitting your internal service.

Another option is to use a service like [Traefik](https://traefik.io/) or [Caddy](https://caddyserver.com/) that can automate HTTPS and basic auth for you.

If you want to manage many domains & services, I'd recommend [Nginx Proxy Manager](https://nginxproxymanager.com/).

## üîç Monitoring & Verification

This is the **most important & most overlooked step.** You can have the best firewall, the best network, and the best practices, but if you don't verify, you have no idea if it's working.

<p class="inset">Don‚Äôt Trust, Verify Twice</p>

### Checking for Exposed Ports

#### Test Inside Your Network

Whether you‚Äôre on a home network or a VPS, you can use `nmap` to scan for open ports. It's quite handy to know how to check for open ports.

Practice using `nmap`, scan your local network or one of your servers, check your router, printer, smart fridge.

<p class="inset">‚ö†Ô∏è Alert: Do not scan hosts you do not own. (Like `google.com`.)</p>

While port scans are a constant fact of life, it's possibly a violation of the CFAA (Computer Fraud and Abuse Act) in the US. So, don't do it without permission.

#### Examples Scan Commands

```bash
# Scan your localhost for all open ports
nmap -sT localhost

# Scan your machine‚Äôs private IP for services
nmap -sV 192.168.1.10

# Detect devices on your network
nmap -sn 192.168.0.0/24
nmap -sn 10.0.0.0/24
```

#### Testing Outside Your Network

You'll need your current (public) IP easily with services like `ifconfig.me`: `curl https://ifconfig.me`. Or look it up in your hosting provider's dashboard.

Test from a different network, cell hot-spot, or another remote server to test your public IPs:

```bash
print_current_ip() {
  curl https://ifconfig.me
}

print_current_ip
# --> 123.456.789.012

# Change target_host to your public ip or hostname
# Check host using advanced techniques
nmap -A --open --reason $target_host
nmap -A -F --open --reason $target_host
nmap -A -p1-65535 --open --reason $target_host

```

**Why Test Both?**

Testing from inside reveals internal exposure, while external tests identify services accessible to attackers.

### View Connections with `lsof`

```bash
# Monitor all network connections
sudo watch -n1 "lsof -i -Pn"

# Monitor specific port
sudo lsof -i:80 -Pn

# Monitor ESTABLISHED connections
sudo lsof -i -Pn | grep ESTABLISHED
# View LISTEN
sudo lsof -i -Pn | grep LISTEN

# to see network names instead of IP addresses (can be very slow to do reverse DNS lookups)
sudo lsof -i -P | grep LISTEN

```

#### Example Output

![nmap scan for listeners](nmap-scan-listen.webp)

### File monitoring

To identify which **processes are using the most hard drive bandwidth**, you can use `iotop`:

```bash
sudo iotop -o
```

To see individual file changes, you can use `inotifywait` on Linux or `fswatch` on MacOS:

This can be useful to detect unauthorized or strange behavior per folder or system wide.

```bash
# Monitor all file changes in a directory
sudo inotifywait -m /path/to/directory
```

On MacOS you can use `fswatch`:

Install with `brew install fswatch`

```bash
fswatch -r /path/to/directory
```

## ‚è∞ Parting Thoughts

### Often Overlooked Tips

1. Place [**Canary Tokens**](https://canarytokens.org/) in every sensitive `.env` file, CI platform, and "secrets manager" you can find! You have types of canary's from [fake credit card](https://blog.thinkst.com/2024/12/its-baaack-credit-card-canarytokens-are-now-on-your-consoles.html) numbers, AWS keys, Excel & Word files, Kubeconfig files, VPN credentials, even sql dump files can have a tripwire!

If someone tries to use them, you‚Äôll know right away. You may not know when or how... but you just might get a chance to stop some damage.

create an AWS profile ddz If triggered, you‚Äôll get an email (or slack ping) and know instantly that something has gone wrong.
   *Try [Canarytokens.org]()*

2. **Rate Limiting** for authentication attempts & any other key endpoints. Whether via Nginx‚Äôs `limit_req` module or `fail2ban`, throttling brute-force is _probably_ a good idea. I say _probably_ because in the age of IPv6 and botnets-for-cheap, well, it's not what it used to be.

3. **Use Read-Only Volumes** wherever possible:
   ```yaml
   services:
     webapp:
       volumes:
         - ./config:/config:ro
   ```
   This prevents accidental (or malicious) changes to critical files.

4. **Audit Docker Socket Access** regularly.
   If a container doesn‚Äôt need it, remove the mount.

5. **Beware of WiFi Riff-Raff**
   On a home network, we never let strangers join our network. Well, except friends. Or family. Or that neighbor who always asks for the password. Actually‚Ä¶ maybe that‚Äôs you. If so, please check your firewall.

### Comparing Home Network vs Public Providers

1. **Virtual Isolation/DMZ**: For home servers, put them on a separate VLAN or DMZ if possible. This keeps your internal devices off-limits to potential compromise from the server side.
   - **Direct Internet-Facing**: Easiest route but highest risk.
   - **Gatewayed Networks**: Traffic is filtered, requires NAT/port forwarding.

2. **Cloud Providers**: Vultr, DigitalOcean, Linode, AWS, Azure, and Google Cloud all provide out-of-the-box firewall/security group features.
   - Typically, these providers block all ports except what you explicitly open.
   - They also offer advanced monitoring and threat detection tools.

3. **Hardening Against Internal/Lateral Attacks**: One infected device can expose the entire network. Segmenting Docker services on custom networks, using UFW rules, and blocking unneeded ports can all help reduce risk (when properly configured.)

## üöÄ Production Checklist

- [ ] **Secrets**: All secrets randomly generated and securely stored
- [ ] **Updates**: Container update strategy documented and automated
- [ ] **Network**: Only necessary ports exposed, internal networks set up
- [ ] **Firewall Rules**: Default deny, explicit allows, country blocks if needed
- [ ] **Reverse Proxy**: Nginx, Caddy or Traefik can add a layer of basic auth
- [ ] **Canary Tokens**: Place them alongside all sensitive keys. In every `.env` you have floating around.
- [ ] **Monitoring**: `nmap`, `lsof`, `inotifywait`, and `glances` set up
- [ ] **Backup Strategy**: Tested and automated
- [ ] **Least Privilege**: Non-root container users, read-only volumes


## üìö Further Reading

- [Docker Security Best Practices](https://docs.docker.com/develop/security-best-practices/)
- [OWASP Docker Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)
- [Canarytokens.org for Canary Tokens](https://canarytokens.org/)

## Thanks

A shout-out to some keen Redditors:

- <em className="cite">Thanks [u/JCBird1012](https://www.reddit.com/user/JCBird1012/) - [credit](https://www.reddit.com/r/selfhosted/comments/1hv8jn6/comment/m5rvlzi/).</em>


Thanks for reading! I hope you found this guide helpful. If you have any questions or suggestions, feel free to reach out on my social icon links below, or click the `Edit on GitHub` link to create a PR!

---
title: "Essential Docker Security Tips for Self-Hosting"
subTitle: "Tips for securing your Self-hosted Docker services - from network security to monitoring!"
date: 2025-01-04
modified: 2025-01-07
tags: [docker, security, devops, containers, best-practices]
category: Security

social_image: desktop-social.webp
cover_full_width: docker-ukiyo-e-wide.webp
cover_mobile: docker-ukiyo-e-container-square-200.webp
cover_icon: docker-ukiyo-e-container-square-200.webp
cover_credit: ¬© 2025 Dan Levy
---

import {CodeTabs} from '../../../components/CodeTabs';

**Table of Contents**

- üßó‚Äç‚ôÄÔ∏è [For the brave](#-for-the-brave)
- üîÑ [The `:latest` Dance](#-the-latest-dance)
- üîê [Secrets Management: The Right Way](#-secrets-management)
- üåê [Network Hazard](#-network-hazard)
- üõ°Ô∏è [Access Controls](#Ô∏è-access-controls)
- üîç [Monitoring & Verification](#-monitoring--verification)
- ‚è∞ [Late Night Thoughts](#-late-night-thoughts)
- üöÄ [Production Checklist](#-production-checklist)
- üìö [Further Reading](#-further-reading)
- üôè [Thanks](#thanks)


## üßó‚Äç‚ôÄÔ∏è For the brave

If you‚Äôre self-hosting Docker services, security is your responsibility from top to bottom‚Äîno cloud provider to shield you from port scans or sloppy config. Whether you‚Äôre spinning up apps on your home network or renting VPSes from providers like Vultr, DigitalOcean, Linode, AWS, Azure, or Google Cloud, you‚Äôll need to lock things down - and verify you did it right.

In this guide, we‚Äôll walk through Docker security‚Äîfrom some `lesser-known` to other `difficult-to-get-right` techniques; we'll explore canary tokens, read-only volumes, firewall rules, network segmentation & hardening, adding authenticated proxies, and more.

We‚Äôll also compare home networks to public cloud setups and show you how to set up a basic auth proxy with Nginx. By the end, you‚Äôll have several options to keep out the riff-raff (friends, family, and sometimes even yourself...)

That's a ton of stuff! But much of it relates, and you can pick and choose what's most relevant to your setup. üçÄ

## üîÑ The `:latest` Dance

Keeping images updated is crucial for security. However, relying blindly on `:latest` can lead to breaking changes or vulnerabilities creeping in unnoticed.

### The Safe Way to Update

```bash
#!/bin/bash
# update-and-run.sh
docker compose pull && \
docker compose down && \
docker compose up -d
```

### Version Pinning vs Latest

```yaml
# docker-compose.yml
# ...
  # Exact version pinning, best for critical services
  image: postgres:17.2.1

  # Patch version pinning, good for non-critical services
  image: postgres:17.2

  # Major version pinning, perfect for hobby projects
  image: postgres:17

  # Yolo, avoid if possible
  image: postgres:latest
```

Use [Dependabot](https://github.com/features/security) or [Renovate](https://github.com/renovatebot/renovate) to automate version updates and ensure you‚Äôre reviewing changes before they break production.

_Let me know about your favorite tools for keeping Docker images up-to-date!_

## üîê Secrets Management

Never bake your secrets (API tokens, passwords, keys) into Docker images **_OR_** commit them to git.

Keep secrets out of your repos & containers - and rotate them periodically!

### Generate Strong Secrets

```bash
#!/bin/bash
# generate-secrets.sh

generate_secret() {
    local length=${1:-30}
    local generate_length=$((length + 4))
    openssl rand -base64 "$generate_length" | tr -d '+=/\n' | cut -c1-"$length"
}

[ -f .env ] && { echo ".env file already exists!"; exit 1; }

cat > .env << EOL
POSTGRES_PASSWORD=$(generate_secret)
JWT_SECRET=$(generate_secret 64)
SESSION_KEY=$(generate_secret 24)
REDIS_PASSWORD=$(generate_secret 20)
UNSAFE_PLACEHOLDER=__WARNING_REPLACE_RANDOM_TEXT__
EOL

echo "New .env file generated with secure random values!"
```


### Defensive Placeholder Validation

<blockquote>You wouldn't believe how easy it is to hack a JWT token when the secret isn't secret!</blockquote>

<p className='inset'>üí° Ensure secrets are always unique. Try make it impossible to run with unsafe/hard-coded defaults.</p>

If you use placeholders like `__WARNING_REPLACE_ME__` in your secrets, great, maybe someone will notice!

Just in case, you can also add a little runtime safety with little effort. Here‚Äôs how you might do it in JavaScript, Rust, and Go:

<CodeTabs client:load tabs={["JavaScript", "Rust", "Go"]}>

```javascript
// validateSecrets.js
const validateSecrets = () => {
  const unsafePlaceholder = /__WARNING_REPLACE_ME__/;
  const missingSecrets = Object.entries(process.env).filter(
    ([key, value]) => unsafePlaceholder.test(value)
  );

  if (missingSecrets.length) {
    console.error("Unsafe secrets detected:", missingSecrets);
    process.exit(1);
  }
};

validateSecrets();
```

```rust
// validate_secrets.rs
use std::env;

fn validate_secrets() {
    let unsafe_placeholder = "__WARNING_REPLACE_ME__";
    for (key, value) in env::vars() {
        if value.contains(unsafe_placeholder) {
            panic!("Unsafe secret in {}", key);
        }
    }
}

fn main() {
    validate_secrets();
}
```

```go
// validate_secrets.go
package main

import (
	"fmt"
	"os"
	"strings"
)

func validateSecrets() {
	placeholder := "__WARNING_REPLACE_ME__"
	for _, env := range os.Environ() {
		pair := strings.SplitN(env, "=", 2)
		if len(pair) == 2 && strings.Contains(pair[1], placeholder) {
			panic(fmt.Sprintf("Unsafe secret in %s", pair[0]))
		}
	}
}

func main() {
	validateSecrets()
}
```

</CodeTabs>

## üåê Network Hazard

### Custom Networks & Internal Ports

```yaml
networks:
  backend:
# Existing "external" named network
    internal: true 

services:
  webapp:
    networks:
      - backend
    ports:
      - "127.0.0.1:8080:8080" # Expose locally only
  database:
    networks:
      - backend
    # No published ports, only accessible inside backend network
```

Properly isolating services with Docker networks can reduce your attack surface. Services on a private or internal network won‚Äôt be accessible from the public internet.

### Docker on LAN

Whether you're a developer running dev servers locally, or self-hosting services from your local network, assumptions about docker's network model can lead to trouble.

Devs are often surprised to find the 'traditional' methods to secure linux servers (`iptables`, restricting tcp/ip sysctl options) can **fail silently** on Docker hosts! This is especially the case when **self-hosting-or running on a typical home network.** (For the people in the back: This can allow access to dev containers on your MacBook!!!)

<p class="inset">If you're surprised to hear this, same. I was too!</p>

> ‚ö†Ô∏è **Warning #1:** By default, Docker (on Ubuntu/Debian) will bypass UFW/iptables rules, rendering **your firewall useless.** [See issue #690: Docker bypasses ufw firewall rules](https://github.com/moby/moby/issues/690).

> ‚ö†Ô∏è **Warning #2:** Binding ports to local IP addresses (e.g., `-p 127.0.0.1:8080:80`) may offer only limited protection. [See issue #45610: Publishing ports explicitly to private networks should not be accessible from LAN hosts](https://github.com/moby/moby/issues/45610). (Impacts Fedora, Ubuntu, and likely others.)

**Binding to local IPs is still a good practice** and has a meaningful impact in **managed cloud environments and specially configured networks.** 

<details>
<summary>Why is this the case?</summary>
Most home network setups allow MAC-based Layer 2 (L2) routing to take precedence over IP-based Layer 3 (L3) routing. This means that the local IP binding may not be as effective as you might expect.
</details>

Don't think of your firewall or private network as your main defense, embrace Docker Networks for better **isolation**, and always consider if you need to expose ports at all.

#### Network Best Practices

- üèÜ **Don't Publish ANY Ports** Recently I learned this is more useful than you might expect! When using a bridge network, containers have unfiltered access to each other. They behave as though they are behind a local network (NAT gateway.)
  - While not possible in all use cases, this may be useful for containers running batch jobs, or mostly accessed via `attach` or `exec`.
- ü•á **Use Docker Networks** to isolate and control which containers can talk to each other.
- ü•â **Use Localhost Binding**: While [sometimes easy to bypass](https://github.com/moby/moby/issues/45610), you're generally better off binding ports with a local or loopback address (e.g., `127.0.0.1:8080:80`). Just know of the risk in certain contexts.

#### Test & Verify

As with all security measures, it's critical that you **test and verify** your network setup.

While network security & auditing is a full-time responsibility in most companies, most self-host folks don't spend ANY time on it!

Look, I get it, it can be intimidating. _(Subnets, net masks, CIDR, VLANs, and routing tables, oh my! If that made no sense, that's ok, you're in the right place. Also, we don't need to worry about any of that for now.)_

Knowing just a handful of commands-or where to look them up-can mean all the difference in preventing a breach. The extra peace of mind, plus the low-key feeling of being a hacker, is all a bonus.

> For details and examples, jump ahead to the [Monitoring & Verification](#-monitoring--verification) section.

**Cross-linked Resources:**
- [Blocking Traffic by Country](#blocking-country) 

## üõ°Ô∏è Access Controls

### Limiting Container Capabilities

Another solid access control practice is to limit the capabilities of your containers. This can prevent several threats, from privilege escalation, data theft/exfiltration, traffic hijacking, and more.

**What are capabilities?** Linux kernel-defined, named permissions or abilities. (The [`capabilities`](https://man7.org/linux/man-pages/man7/capabilities.7.html) man page has a full list.) They include things like `CAP_CHOWN` (change file ownership), `CAP_NET_ADMIN` (configure network interfaces), `CAP_KILL` (kill any process), and many more.

The two ways to determine needed capabilities are:

1. **Trial and Error**: This slower-but-effective method has you start with no capabilities, then add them back one by one until your app works.
2. **Find prior work**: Search for "`project-name` `cap_drop` Dockerfile", or "`project-name` `cap_drop` docker-compose.yml" to see if others have already done the work for you. Sometimes ChatGPT can conjure up the right configuration for you, too!

#### Capabilities Best Practice

- **Drop All Capabilities**: Use `cap_drop: [ ALL ]` to drop all Linux capabilities from the container.
- **No New Privileges**: Use `security_opt: [ no-new-privileges=true ]` to prevent the container from gaining new privileges.

```yaml title="Example: Drop/Limit Capabilities" {5-14}
services:
  database:
    image: postgres:17.1
    networks: [ db-network ]
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_READ_SEARCH
      - FOWNER
      - SETGID
      - SETUID
  db-admin:
    image: dpage/pgadmin4:4.1
    networks: [ db-network ]
    ports:
      - "8081:80"
    # ... other settings
networks:
  db-network:
```

Now your services can communicate with each other via the `db-network` network. The `auto-net` network will be created automatically by Docker Compose.

Use the `--external`/`external:` option to join a **pre-existing network.** Omit it to create a new network.

### Docker Socket Access

#### ‚ö†Ô∏è Warning: `docker.socket` is extremely powerful and dangerous dark magic!

<blockquote class="inset">‚ö†Ô∏è The \`:ro\` option doesn't affect I/O sent over the socket!</blockquote>

It merely ensures the file (a Unix socket, not a file in the traditional sense) itself is `read-only`.

{/* Any process that can "open" the socket can (probably) gain root access on the host. */}

#### Socket Best Practice

- ü•á **Avoid mounting a docker socket,** there's likely a better alternative!
- ü´£ If you must, **use a Reverse Proxy** to limit what API commands are available. Check out the `docker-socket-proxy` project originally from Tecnativa, [docker-socket-proxy](https://github.com/Tecnativa/docker-socket-proxy).
- ü§¢ Okay, _maybe_ sharing it is okay in a very **high-trust**, **low-risk** test environment.

#### Blocking Country!

Another decent idea!

_Talking about the geopolitical entity, not the music..._

If you are hosting apps mostly for your local family & friends, you can block traffic from countries you don't expect to receive traffic from. Or only allow traffic from countries you do expect.

Check out this script to block all traffic from China:

```bash title="block-china.sh"
wget -O- https://www.ipdeny.com/ipblocks/data/countries/cn.zone | \
  while read line; do ufw deny from $line to any; done
```

#### Hardening CloudFlare Proxy Host

If your home server is protected behind a CloudFlare IP (proxy,) you can restrict access to only CloudFlare IPs, and your local network.

This is a bit similar to [Country blocking](#blocking-country) above, but with much tighter control.

```bash title="whitelist-ingress-from-cloudflare.sh"
ufw default deny incoming # Block all incoming!!!
ufw default allow outgoing # Allow all outgoing
ufw allow ssh # Allow SSH

# Allow access for local subnet (preferably dedicated subnet for hosted services)
ufw allow from 10.0.0.0/8 to any port 443

# Allow CloudFlare IPs
wget -O- https://www.cloudflare.com/ips-v4 | \
  while read line; do ufw allow from $line to any port 443; done
# Add IPv6 support
# wget -O- https://www.cloudflare.com/ips-v6 | \
  # while read line; do ufw allow from $line to any port 443; done
```

### App Layer Security

Once your [network and host are security hardened,](#-network-hazard) you may find there's more to do.

Now we need to think about the "application" layer of our services themselves.

<p class="inset">Does that database have a valid password? Does this container automate HTTPS/certs? Does the app include built-in auth? Are there limits on which emails can signup? Are there default credentials or environment variable to change?</p>

The only way to _know_ is to check. In this case, read the README and any other key files like `docker-compose.yml`, `Dockerfile`, and `.env.*`. In both the project, and ideally its supporting services as well. (e.g. Postgres, Redis, etc.)

#### Reverse Proxy

Another layer of defense is basic auth. I know it's dangerous to use without HTTPS, but sometimes it's the best you can do, and it's often enough to stop automated Cross-Site-Request-Forgery attacks.

```nginx
# /etc/nginx/conf.d/secure-admin.conf
location /admin {
    auth_basic "Restricted Access";
    auth_basic_user_file /etc/nginx/.htpasswd;
    proxy_pass http://internal_admin:80;
    proxy_set_header X-Real-IP $remote_addr;
}
```

Generate credentials:

```bash
htpasswd -c /etc/nginx/.htpasswd admin
```

With a basic auth proxy, attackers have an extra hurdle‚Äîusername and password‚Äîbefore hitting your internal service.

Another option is to use a service like [Traefik](https://traefik.io/) or [Caddy](https://caddyserver.com/) that can automate HTTPS and basic auth for you.

If you want to manage many domains & services, I'd recommend [Nginx Proxy Manager](https://nginxproxymanager.com/).

## üîç Monitoring & Verification

This is the **most important & most overlooked step.** You can have the best firewall, the best network, and the best practices, but if you don't verify, you have no idea if it's working.

<p class="inset">Don‚Äôt Trust, Verify Twice</p>

### Checking for Exposed Ports

#### Test Inside Your Network

Whether you‚Äôre on a home network or a VPS, you can use `nmap` to scan for open ports. It's quite handy to know how to check for open ports.

Practice using `nmap`, scan your local network or one of your servers, check your router, printer, smart fridge.

<p class="inset">‚ö†Ô∏è Alert: Do not scan hosts you do not own. (Like `google.com`.)</p>

While port scans are a constant fact of life, it's possibly a violation of the CFAA (Computer Fraud and Abuse Act) in the US. So, don't do it without permission.

#### Examples Scan Commands

```bash
# Scan your localhost for all open ports
nmap -sT localhost

# Scan your machine‚Äôs private IP for services
nmap -sV 192.168.1.10

# Detect devices on your network
nmap -sn 192.168.0.0/24
nmap -sn 10.0.0.0/24
```

#### Testing Outside Your Network

You'll need your current (public) IP easily with services like `ifconfig.me`: `curl https://ifconfig.me`. Or look it up in your hosting provider's dashboard.

Test from a different network, cell hot-spot, or another remote server to test your public IPs:

```bash
print_current_ip() {
  curl https://ifconfig.me
}

print_current_ip
# --> 123.456.789.012

# Change target_host to your public ip or hostname
# Check host using advanced techniques
nmap -A --open --reason $target_host
nmap -A -F --open --reason $target_host
nmap -A -p1-65535 --open --reason $target_host

```

**Why Test Both?**

Testing from inside reveals internal exposure, while external tests identify services accessible to attackers.

### View Connections with `lsof`

```bash
# Monitor all network connections
sudo watch -n1 "lsof -i -Pn"

# Monitor specific port
sudo lsof -i:80 -Pn

# Monitor ESTABLISHED connections
sudo lsof -i -Pn | grep ESTABLISHED
# View LISTEN
sudo lsof -i -Pn | grep LISTEN

# to see network names instead of IP addresses (can be very slow to do reverse DNS lookups)
sudo lsof -i -P | grep LISTEN

```

#### Example Output

![nmap scan for listeners](nmap-scan-listen.webp)

### File monitoring

To identify which **processes are using the most hard drive bandwidth**, you can use `iotop`:

```bash
sudo iotop -o
```

To see individual file changes, you can use `inotifywait` on Linux or `fswatch` on MacOS:

This can be useful to detect unauthorized or strange behavior per folder or system wide.

```bash
# Monitor all file changes in a directory
sudo inotifywait -m /path/to/directory
```

On MacOS you can use `fswatch`:

Install with `brew install fswatch`

```bash
fswatch -r /path/to/directory
```

## ‚è∞ Late Night Thoughts



### Often Overlooked Tips

1. Place [**Canary Tokens**](https://canarytokens.org/) in every sensitive `.env` file, CI platform, and "secrets manager" you can find! You have types of types of canary tokens to chose from, [fake credit card](https://blog.thinkst.com/2024/12/its-baaack-credit-card-canarytokens-are-now-on-your-consoles.html) numbers, AWS keys, Excel & Word files, Kubeconfig files, VPN credentials, even sql dump files can have a tripwire!
   If someone tries to use them, you‚Äôll know there was a breach _right away_. That's pretty cool, even if it sends you on a wild goose chase every now and then.

2. **Rate Limiting** for authentication attempts & any other key endpoints. Whether via Nginx‚Äôs `limit_req` module or `fail2ban` for SSH access, throttling brute-force is _probably_ a good idea. I say _probably_ because in the age of IPv6 and botnets-for-cheap, well, it's not what it used to be.

3. **Use Read-Only Volumes** where possible:
   ```yaml
   services:
     webapp:
       volumes:
         - ./config:/config:ro
   ```
   Combined with other best practices (non-root users, minimal folder permissions), the \`:ro\` volume mount option provides additional safe-guards against accidental (or malicious) changes to critical files.

4. **Audit Container Access** regularly.
   If a container doesn‚Äôt need it a secret, port or mount, remove it!

5. **Beware of WiFi Riff-Raff**
   I'm sure you'd never give out your WiFi password, especially to any weirdos, right? Well, except some friends... Okay, maybe family too.

### Comparing Home Network vs Public Providers

1. **Virtual Isolation/DMZ**: For home servers, put them on a separate VLAN or DMZ if possible. This keeps your internal devices off-limits to potential compromise from the server side.
   - **Direct Internet-Facing**: Easiest route but highest risk.
   - **Gatewayed Networks**: Traffic is filtered, requires NAT/port forwarding.

2. **Cloud Providers**: Vultr, DigitalOcean, Linode, AWS, Azure, and Google Cloud all provide out-of-the-box firewall/security group features.
   - Typically, these providers block all ports except what you explicitly open.
   - They also offer advanced monitoring and threat detection tools.

3. **Hardening Against Internal/Lateral Attacks**: One infected device can compromise an entire network. Segmenting Docker services on custom networks, using UFW rules, and blocking unneeded ports can all help reduce risk (when properly configured.)

## üöÄ Production Checklist

- [ ] **Secrets**: All secrets randomly generated and securely stored
- [ ] **Updates**: Container update strategy documented and automated
- [ ] **Network**: Only necessary ports exposed, internal networks set up
- [ ] **Firewall Rules**: Default deny, explicit allows, country blocks if needed
- [ ] **Reverse Proxy**: Nginx, Caddy or Traefik can add a layer of basic auth
- [ ] **Canary Tokens**: Place them alongside all sensitive keys. In every `.env` you have floating around.
- [ ] **Monitoring**: `nmap`, `lsof`, `inotifywait`, and `glances` set up
- [ ] **Backup Strategy**: Tested and automated
- [ ] **Least Privilege**: Non-root container users, read-only volumes


## üìö Further Reading

- [Docker Security Best Practices](https://docs.docker.com/develop/security-best-practices/)
- [OWASP Docker Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)
- [Canarytokens.org for Canary Tokens](https://canarytokens.org/)

## Thanks

A shout-out to some keen Redditors:

- <em className="cite">Thanks [u/JCBird1012](https://www.reddit.com/user/JCBird1012/) - [thread](https://www.reddit.com/r/selfhosted/comments/1hv8jn6/comment/m5rvlzi/).</em>
- <em className="cite">[u/Salzig](https://www.reddit.com/user/Salzig/)</em>
- <em className="cite">[u/Myelrond](https://www.reddit.com/user/myelrond/)</em>
- <em className="cite">[u/shrimpdiddle](https://www.reddit.com/user/shrimpdiddle/)</em>

Thanks for reading! I hope you found this guide helpful. If you have any questions or suggestions, feel free to reach out on my socials below, or feel free to click the `Edit on GitHub` link to create a PR! ‚ù§Ô∏è

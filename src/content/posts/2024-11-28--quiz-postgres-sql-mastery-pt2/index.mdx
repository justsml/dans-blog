---
unlisted: false
social_image: mobile.webp
title: "Quiz: Deep Postgres: Pt. 2"
subTitle: "Are you SQL Steele? Or a SQL Softie?"
label: "Deep PostgreSQL #2"
category: Quiz
subCategory: Database
date: 2024-11-28
modified: 2024-12-02
tags: [quiz, postgresql, sql, database, intermediate, advanced]
cover_full_width: dancing-postgres-elephant-wide.webp
cover_mobile: dancing-postgres-elephant-square.webp
cover_icon: dancing-postgres-elephant-square.webp
---
import Challenge from '../../../components/QuizUI/Challenge';
import QuizUI from '../../../components/QuizUI/QuizUI';

> **Part 2 of 2.** [Back to Part 1](/quiz-postgres-sql-mastery-pt1/)

<p class="inset">Welcome to Part 2 of my Deep Postres Quiz!</p>

This quiz covers a mix of familiar and lesser-known PostgreSQL features and gotchas: `JOIN`, `NULL`, ANSI SQL, Transactions, Internals, Indexing, Data Sampling... and more!

Good luck! üçÄ

<QuizUI>

<Challenge
  client:load
  index={0}
  group="Warmup: Joins"
  title="The Many JOINs of PostgreSQL"
  options={[
    {text: 'JOIN ALL', isAnswer: true},
    {text: 'INNER JOIN'},
    {text: 'CROSS JOIN'},
    {text: 'LEFT OUTER JOIN'},
    {text: 'FULL OUTER JOIN'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is not ‚ùå a valid PostgreSQL JOIN expression?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    You knew about `CROSS JOIN`, right?

    Did the `JOIN ALL` get you thinking about another operation, `UNION ALL`?

    The answer here is `JOIN ALL` ‚ùå.

    The correct JOIN types are:
    - `INNER JOIN` (default JOIN)
    - `LEFT JOIN` (or `LEFT OUTER JOIN`)
    - `RIGHT JOIN` (or `RIGHT OUTER JOIN`)
    - `FULL JOIN` (or `FULL OUTER JOIN`)
    - `CROSS JOIN` (aka "The Self Join," aka "The Lonely JOIN," famously known-at-parties as the `Cartesian product`!)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={1}
  group="Identity Columns"
  title="The Modern Way to Auto-Increment"
  options={[
    {text: 'id SERIAL PRIMARY KEY', },
    {text: 'id BIGSERIAL PRIMARY KEY'},
    {text: 'id INTEGER AUTO_INCREMENT PRIMARY KEY'},
    {text: 'id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    What is the _SQL Standard_ compliant way to create an auto-incrementing primary key in PostgreSQL 10+?

    We're creating a table to track students:
    ```sql
    CREATE TABLE students (
      -- Which syntax should we use here? ü§î
      name VARCHAR(100) NOT NULL
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    While `SERIAL` is still commonly used, the SQL Standard way is:
    ```sql
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    ```

    This has several advantages over `SERIAL`:
    - It's SQL Standard compliant
    - Better handling of sequence ownership
    - Clearer semantics around manual inserts
    - Works better with replication

    `SERIAL` is actually just shorthand for creating a sequence and setting a default value, which can lead to issues with dumps and restores.
  </div>
  </slot>
</Challenge>
<Challenge
  client:load
  index={2}
  group="ANSI SQL"
  title="Standards Compliance"
  options={[
    {text: 'INTO'},
    {text: 'WITH'},
    {text: 'LATERAL'},
    {text: 'RETURNING', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these PostgreSQL features is **NOT** ‚ùå part of the ANSI SQL standard?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Examples of PostgreSQL extensions to ANSI SQL:
    - `RETURNING` clause.
    - `ILIKE` for case-insensitive matching.
    - Array types and operations.
    - JSON/JSONB types.
    
    The original ANSI SQL standard includes:
    - `WITH` (Common Table Expressions).
    - `LIKE` for pattern matching.
    - `LATERAL` joins.
    - Window functions.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={3}
  group="Transactions"
  title="Automatic Rollback"
  options={[
    {text: 'Depends on side effects'},
    {text: 'Rolls back all statements', isAnswer: true},
    {text: 'Commits first statement only'},
    {text: 'Commits all successful statements'},
  ]}
>
  <slot name="question">
  <div className="question">
    Except for "Depends on side effects" 
    What happens after an error?
    ```sql
    BEGIN;
    UPDATE students
      SET status = 'alumni'
      WHERE grade = 12;
    UPDATE students
      SET graduation_date = CURRENT_DATE
      WHERE grade = 12;
    UPDATE students
      SET grade = 'GRADUATED'; -- üö® Error: type mismatch
    COMMIT;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    When an error occurs here:
    - The **entire** transaction is rolled back
    - No changes are committed
    - The transaction is marked as failed

    To partially commit:
    ```sql
    BEGIN;
    UPDATE ...;
    SAVEPOINT my_save;
    UPDATE ...; -- Error
    ROLLBACK TO my_save;
    COMMIT;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={4}
  group="SQL Internals"
  title="Hash Join Triggers"
  options={[
    {text: 'ON a.id = b.id', isAnswer: true},
    {text: 'ON a.id > b.id'},
    {text: 'ON a.id >= b.id'},
    {text: 'HASH JOIN ON a.id = b.id ...'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which `ON` condition triggers a `HASH JOIN` in PostgreSQL?
    ```sql
    SELECT *
    FROM students a
    JOIN grades b
    ON /* What goes here? ‚Åâ */;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    A hash join is triggered by an equality (`=`) condition in the `ON` clause.

    - `=` is the most common hash join trigger
    - `>` and `>=` trigger a merge join
    - `HASH JOIN` is not a valid syntax in PostgreSQL

    Hash joins are efficient for large tables, but require enough memory to build the hash table.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={5}
  group="Indexing"
  title="Multi-Column Index Order"
  options={[
    {text: 'CREATE INDEX ON students.grade_level;\nCREATE ... students.last_name;'},
    {text: 'CREATE INDEX ON students(grade_level, last_name);', isAnswer: true},
    {text: 'CREATE INDEX ON students(grade_level);'},
    {text: 'CREATE INDEX ON students(last_name, grade_level);'},
    {text: 'CREATE INDEX ON students(first_name, last_name, grade_level);'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which index is better for this query?
    ```sql
    -- Query:
    SELECT * FROM students
    WHERE grade_level = 42
      AND last_name LIKE 'Levy%';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Put the most *selective* column first in multi-column indexes. `Selectivity` is _roughly_ referring to the order the columns appear in the query.

    A B+Tree index can be used for:
    - Any subset of columns.
    - Right-hand-side wildcard searches (`LIKE 'Levy%'`).

    Consider query patterns and column cardinality when designing indexes!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={6}
  group="Quoting 1"
  title="Proper Quoting"
  options={[
    {text: 'Both work the same'},
    {text: 'Double quotes are required', isAnswer: true},
    {text: 'Single quotes are required'},
    {text: 'Syntax error: Invalid user literal'},
    {text: 'All names MUST be lowercase'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is correct for case-sensitive column names?
    ```sql
    CREATE TABLE grades (
      "Student Name" VARCHAR(100),
      'Student Grade' INTEGER
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    In PostgreSQL:
    - Double quotes (`"`) are for identifiers (table names, column names)
    - Single quotes (`'`) are for string literals

    Best practices:
    - Avoid mixed case or spaces in names
    - Use snake_case for identifiers
    - Only use quoted identifiers when absolutely necessary
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={7}
  group="Quoting 2"
  title="Column Name Quoting"
  options={[
    {text: 'first.name'},
    {text: '"first.name"', isAnswer: true},
    {text: '\'first.name\''},
    {text: '[first.name]'},
    {text: '[first].[name]'},
  ]}
>
  <slot name="question">
  <div className="question">
    How do you specify a **column name containing a period?**
    ```sql
    CREATE TABLE teachers (
      id INT GENERATED BY DEFAULT AS IDENTITY,
      first.name TEXT,
      -- How do you include the column: first.name?
      salary NUMERIC
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL uses double quotes for identifier quoting:
    - Double quotes `"..."` for identifiers (column names, table names)
    - Single quotes `'...'` for string literals
    - The form `first.name` is interpreted as `table_name.column_name`

    Without quotes, a period in a column name would be interpreted as a schema/table separator! Additionally, all unquoted identifiers are lower-cased by default.

    In order to reduce surprises, it's best to use `snake_case` and avoid using special characters.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={8}
  group="Data Sampling"
  title="TABLESAMPLE Syntax"
  options={[
    {text: '...students SAMPLETABLE BERNOULLI (0.10)'},
    {text: '...students TABLESAMPLE USER (10)'},
    {text: '...students TABLESAMPLE RANDOM (10)'},
    {text: '...students SAMPLE 10 PERCENT'},
    {text: 'ROW_NUMBER() OVER (ORDER BY RAND())'},
    {text: 'ORDER BY RANDOM() > 10'},
    {text: 'WHERE RANDOM() <= 0.1', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is valid syntax to **randomly sample 10%** of students?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This one is tricky! It features roughly 6 traps, some include:

    1. High level description + fragments of syntax. Tests how you adapt & assemble incomplete info.
    2. Requires familiar knowledge of `TABLESAMPLE` syntax, since none of the `TABLESAMPLE` options use the correct syntax! (Sinister! I know! Keep going, I believe in you!!! ‚ù§Ô∏è)
    3. The `ROW_NUMBER() OVER (ORDER BY RAND())` and `ORDER BY RANDOM() > 10` are more red herrings. They look like they could be correct, but they're not. `RAND()` isn't a thing. And `RANDOM() > 10` is a boolean expression that will always be false since `RANDOM()` always is in the range `0.0-1.0`.
    One more problem, the `ORDER BY RANDOM() > 10` would also sort on a boolean value, not a random number. But that `> 10` sure felt like it could be a percentage, right?
    4. `BERNOULLI` is valid, however `SAMPLETABLE BERNOULLI` is not.

    As for the `TABLESAMPLE` method, PostgreSQL supports two sampling methods:
    - `BERNOULLI`: Each row has equal probability
    - `SYSTEM`: Block-level sampling (faster but less random)

    To learn more about sampling, check out this article from [Render](https://render.com/blog/postgresql-random-samples-big-tables).

    Example:
    ```sql
    -- Sample 10% of rows
    SELECT * FROM students TABLESAMPLE BERNOULLI (0.1);

    -- For repeatable results, use REPEATABLE:
    SELECT * FROM students
    TABLESAMPLE BERNOULLI (10) REPEATABLE (42);
    ```

    Also worth mentioning, `TABLESAMPLE` [has been reported](https://stackoverflow.com/questions/8674718/best-way-to-select-random-rows-postgresql) to not be very random. If you need a _more_ random sample, consider using `ORDER BY RANDOM() LIMIT 10`. But be aware that this can be slow on large tables.

    There are also some third-party extensions that provide better random sampling methods, but that's out of scope for this! üòÖ
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Indexing"
  title="Partial Indexes"
  options={[
    {text: 'Invalid syntax'},
    {text: 'Creates duplicate indexes'},
    {text: 'Only indexes active students', isAnswer: true},
    {text: 'Indexes active students first'},
    {text: 'Provides a hint to the query planner'},
  ]}
>
  <slot name="question">
  <div className="question">
    What does this incantation do?
    ```sql
    CREATE INDEX idx_active_students
    ON students(last_name)
    WHERE status = 'active';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This trick is called a `Partial Index`.

    They are useful for reducing disk use & speeding queries when only a subset of rows are typically queried.

    Postgres will only use the index when the `status = 'active'` condition is present in the query.

    **Reminder:** Postgres doesn't support 'query hints' like other RDBMSs. The query planner will decide when to use any appropriate index(es).
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={10}
  group="NULL Behavior"
  title="COUNT and NULL"
  options={[
    {text: '100'},
    {text: '90'},
    {text: '10'},
    {text: '1', isAnswer: true},
    {text: '0'},
  ]}
>
  <slot name="question">
  <div className="question">
    How many *rows* will this return?

    ```sql
    SELECT COUNT(*)
    FROM students
    WHERE grade = NULL;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Ok, this was a little tricky. The gotcha is that `x = NULL` will never match any rows, and it will ALWAYS return one row with a count of `0`.

    Since `NULL` is an unknown value, it can't be compared to anything, not even itself.
    
    The correct way to check for `NULL` values is with `IS NULL`.

    Example:

    ```sql
    postgres=# SELECT count(*)
      FROM students
      WHERE age = null;
    count 
    -------
        0
    (1 row)

    postgres=# 
    postgres=# SELECT count(*)
      FROM students
      WHERE age is null;
    count 
    -------
        3
    (1 row)
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={11}
  group="Performance"
  title="EXPLAIN ANALYZE Gotcha"
  options={[
    {text: 'Lite plan estimate'},
    {text: 'Only works on SELECT'},
    {text: 'Modifies data & emits plan', isAnswer: true},
    {text: 'Simulates execution to get a plan'},
  ]}
>
  <slot name="question">
  <div className="question">
    What does `EXPLAIN ANALYZE` do for `UPDATE` statements?

    ```sql
    EXPLAIN ANALYZE
    UPDATE students
    SET grade = grade + 1
    WHERE status = 'active';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `EXPLAIN ANALYZE` actually executes the query! Be careful analyzing a write operation, specifically `UPDATE`, `DELETE`, and `INSERT` statements. You may have to run cleanup operations after each `EXPLAIN ANALYZE` to get repeatable results.

    Best practices:
    - Use `EXPLAIN` (without ANALYZE) for UPDATE/DELETE/INSERT
    - Wrap modifications in transactions:
    ```sql
    BEGIN;
    EXPLAIN ANALYZE ...;
    ROLLBACK;
    ```
  </div>
  </slot>
</Challenge>

</QuizUI>

Well done! You went deep on several areas of PostgreSQL! üêò

I hope you learned something new, or at least got a score to gloat about! üèÜ

Want more thrills in life? Check out my [Quiz Collection](/challenges/) for endless* fun!

---
language: English
title: "Beware the Single-Purpose People"
subTitle: "So pure it hurts"
category: Code
subCategory: Best Practices
date: 2025-04-03
modified: 2025-04-08
tags: [software development, code organization, maintainability, testing]
---

# A million little pieces

In the realm of software development, the Single Responsibility Principle (SRP) stands as one of my favorite valuable guidelines. The idea that each component should "do one thing and do it well" has helped countless teams create more maintainable, testable code.

But like many good ideas in software, SRP can be taken to harmful extremes.

<p class="inset">Enter the Single-Purpose People, for whom every function must be atomic, every file minimal, every abstraction pure.</p>

## The Value of Single Purpose

Let's acknowledge upfront: the Single Responsibility Principle, applied judiciously, brings real benefits:

- Focused units of code are easier to understand and test
- Clear boundaries help manage complexity
- Modular components can be reused and composed

Even Unix's legendary command-line utilities are often held up as shining examples. The `ls` command lists files - that's it! Simple, right? Well, not quite. Look under the hood and you'll find `ls` is actually a wrapper around system calls like `opendir`, `readdir`, `closedir`, and `stat`. Those system calls in turn interact with the kernel's complex filesystem implementations.

The point is: "single purpose" has always been more about finding practical boundaries than achieving perfect purity.

## When Purity Becomes Poison

The trouble starts when developers become obsessed with splitting everything into the smallest possible units. What begins as a sensible design principle transforms into a refactoring crusade.

The results?

- Source folders that resemble dumping grounds, filled with dozens of tiny 5-line files
- Hidden dependency trees that are impossible to trace mentally
- Webs of imports where files are only referenced once
- Tests so granular and brittle that minor changes cause cascading failures
- Development velocity ground to a halt by constant "re-organization"

I've seen codebases where simple features that should live in a single 100-line file end up scattered across 15+ files, each containing a "pure" function or two. The cognitive overhead of jumping between all these files far outweighs any benefit of the separation.

## The Impact on Teams

This extreme fragmentation takes a serious toll on development teams:

### Productivity Drain

When every small change requires touching multiple files across deeply nested directory structures, even simple tasks become time-consuming expeditions. New team members spend weeks just learning how to navigate the maze of mini-modules.

### Testing Headaches 

The more granular the code, the more brittle the tests tend to become. A minor refactoring can break dozens of tests that are tightly coupled to implementation details. Teams waste countless hours maintaining test suites that provide more friction than value.

### Cognitive Overload

Humans can only hold so much in their working memory. Having to mentally juggle connections between many tiny files makes it harder to reason about program flow and harder to make changes confidently.

## Finding Balance Through Pragmatism

The solution isn't to abandon the Single Responsibility Principle - it's to apply it pragmatically rather than dogmatically. Here's what that means in practice:

- Focus on cohesive modules rather than atomic functions
- Keep related code together unless there's a clear benefit to separation
- Let real-world use cases drive organization, not abstract purity
- Consider the cognitive load on developers
- Test at an appropriate level of granularity

<p class="inset">The goal is maintainable, understandable code - not theoretical perfection.</p>

Sometimes that means a slightly larger file that keeps related functionality together. Sometimes it means accepting that a function does a few closely related things rather than splitting it into three "pure" functions.

The key is staying focused on practical outcomes:
- Can developers easily understand and modify the code?
- Are tests providing valuable confidence without excessive brittleness?
- Is the codebase helping or hindering the team's ability to deliver value?

## Conclusion

The Single Responsibility Principle remains a valuable tool in our engineering toolbox. But like any tool, it must be wielded with skill and judgment - not blind devotion.

When you encounter the Single-Purpose People and their refactoring crusades, remember: our job is to build maintainable, valuable software systems, not to achieve theoretical purity. Stay pragmatic, focus on real-world outcomes, and don't let perfect be the enemy of good.

Your future self (and your teammates) will thank you.
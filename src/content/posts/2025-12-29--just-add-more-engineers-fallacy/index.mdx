---
draft: true
hidden: true
publish: false
title: "The 'Just Add More Engineers' Fallacy"
subTitle: "Why throwing bodies at a late project makes it later."
category: Code
subCategory: Engineering Management
date: 2025-12-29
modified: 2025-12-29
tags: [engineering-management, team-scaling, brooks-law, productivity, software-engineering]
---

## n(n-1)/2

That's the formula that should be tattooed on every engineering manager's arm. It's not the solution to your deadline problem. It's the mathematical proof of why your solution won't work.

You've been in that meeting. The one where someone inevitably suggests we "just add more developers" to hit the deadline. The spreadsheet makes it look so simple: 2 engineers × 3 months = 6 engineer-months of work, so 6 engineers should finish it in 1 month, right? The VP nods approvingly. The PM updates the timeline. Everyone feels productive.

Except the math doesn't work that way, and it never has.

## What Nobody Tells You About Communication Paths

When you have 5 engineers on a team, they can talk to each other in 10 different ways. Add 5 more engineers, and suddenly there are 45 different communication channels to manage. That's the formula at work: n(n-1)/2, where n is your team size.

This isn't a minor inconvenience. This is the difference between "we'll discuss this over lunch" and "let me schedule a meeting with stakeholders." You didn't just double your team capacity. You more than quadrupled the overhead of keeping everyone aligned.

By the time you hit 20 people, you're managing 190 different potential conversations. Your standup is no longer a quick sync. Your architectural decisions require consensus-building. Your merge conflicts become archaeological digs through competing visions of the same feature.

Microsoft's DevDiv team studied this back in 2008, and the findings were uncomfortably clear: coordination costs show up everywhere. Who owns which module? Who needs to be on this call? Why did this merge conflict happen three times this week? Each question represents real time your engineers aren't spending on the actual deadline you're trying to hit.

What's worse, the research in *Accelerate* by Forsgren, Humble, and Kim showed that smaller, more autonomous teams consistently outperform larger ones on both speed and quality. The coordination tax isn't just real. It's measurable, and it's expensive.

## The Three-Month Investment You Don't Have Time For

But let's say you're willing to pay that coordination cost. You've got budget, you've got headcount approval, and you're ready to throw resources at this problem. Great! Now you need to wait three to six months for those resources to actually help.

Your new senior engineers (and you're hiring senior people, right? Because junior engineers would need even more time) spend their first week just getting their development environment working. Then they need to understand your architecture. Not just "we use microservices," but *why* you split the services that way. Not just "we use Redis here," but what happened in the incident two years ago that made you choose Redis over the obvious alternative.

During this time, your existing team is paying the mentorship tax. Every question is legitimate and necessary: "Why did we structure the auth flow this way?" "Who owns the billing service?" "Is this TODO from 2019 still relevant?" Each one pulls someone out of their work. Research by Gloria Mark at UC Irvine found it takes an average of 23 minutes to return to a task after an interruption. If your five new engineers each ask five questions a day, you're burning hours of focus time from the people who are supposed to be hitting that deadline.

Camille Fournier writes in *The Manager's Path* that it takes 3-6 months for a senior engineer to become fully productive in a complex codebase. That's if everything goes well. That's if your documentation is current, your tribal knowledge is accessible, and your domain isn't particularly weird. Most codebases don't meet those criteria.

Month three is particularly dangerous. Your new engineers are confident now. They're writing code! They're productive! Except they don't know about the weird edge case in the payment flow, or the legacy module you're secretly migrating away from, or the incident that taught everyone why we never, ever deploy on Fridays. Some of their code will need refactoring. Some might cause incidents. All of it needs thorough review from those same people who are supposed to be hitting the deadline.

## The Uncomfortable Continuity of Brooks' Law

Fred Brooks wrote about this in 1975. *The Mythical Man-Month* captured a simple truth: "Adding manpower to a late software project makes it later." The book was based on his experience with IBM's OS/360 project, and it included that memorable metaphor: one woman can make a baby in nine months, but nine women can't make a baby in one month.

Five decades later, we have better tools. Our CI/CD pipelines reduce some integration costs. Modern pull request workflows catch issues earlier. A 2019 study in *IEEE Transactions on Software Engineering* found that strong CI/CD practices can reduce integration costs by up to 40%. Async communication tools let us coordinate across time zones. Properly designed microservices can reduce inter-team dependencies.

But humans haven't upgraded. We still need context. We still need to understand the why behind decisions, not just the what. O(n²) is mathematics, not opinion. You can optimize the constant factors in that equation, but you can't escape the fundamental growth rate. Domain expertise still takes time to build, no matter how good your onboarding documentation is.

The technology changes. The math stays the same.

## Amazon Knew This In The Early 2000s

Jeff Bezos instituted the "two-pizza team" rule at Amazon: if a team can't be fed with two pizzas, it's too large. The sweet spot ended up being 5-8 people. This wasn't about pizza budgets or being quirky. Smaller teams make decisions faster because there are fewer stakeholders. They communicate more efficiently because there are fewer paths. They build better systems because ownership is clearer.

In *Team Topologies*, Matthew Skelton and Manuel Pais cite research showing that teams of 7-9 people hit the optimal balance between capability and coordination. Beyond that threshold, you're paying exponentially more in coordination costs for diminishing returns in output. The math catches up with you whether you acknowledge it or not.

## What Actually Works

So what do you do when a project is genuinely late and the deadline is genuinely important?

You reduce scope. I know the business won't like it. But as Marty Cagan writes in *Inspired*, "The reality is that at least half of our ideas are just not going to work." Ship the MVP. Defer the nice-to-haves. Launch without the vanity metrics dashboard. You can iterate in v2.

Kill unnecessary meetings. Simplify approval processes. Give your team actual uninterrupted focus time. Say no to new feature requests. The Toyota Production System has a concept called "removing waste," and sometimes the fastest way forward is to stop doing things that slow you down.

Timebox ruthlessly and ship what you have. When Facebook launched, it was called "Thefacebook" and only worked at Harvard. When AWS launched S3, it had a handful of API calls. As Paul Graham writes in *Hackers & Painters*, "It's better to make a few users really love you than a lot of users kind of like you." Ship the simplest thing that works.

If you absolutely must hire, hire for the next project, not to save this one. Accept the 3-6 month ramp-up time. Invest in pair programming and mentorship. Document *why* decisions were made, not just what they were. Brooks' Law has a corollary: adding people to a project *early* can help, because you pay the onboarding cost before the deadline crunch.

## Why The Fallacy Persists

The "just add more engineers" fallacy survives because it feels like taking action. It demonstrates urgency to stakeholders. It looks impressive on a spreadsheet. It's emotionally satisfying in the moment.

But software development isn't assembly-line work. We're not stamping out widgets where doubling the workers doubles the output. We're solving interconnected problems where context matters, communication matters, and coordination overhead is a real cost that scales quadratically with team size.

The math is clear: five people have 10 communication paths, ten people have 45, twenty people have 190. Onboarding takes months, not weeks. Coordination overhead is a tax you pay on every additional person. These aren't opinions you can argue with in a conference room. They're measurable realities that show up in your velocity charts whether you believe in them or not.

The next time someone suggests adding more engineers to a late project, you'll know what to expect. The project won't be late by days or weeks.

It'll be late by months. And unlike most engineering problems, you can't refactor your way out of this one.

---

## Further Reading

**Books:**
- *The Mythical Man-Month* by Fred Brooks (1975)
- *The Manager's Path* by Camille Fournier (2017)
- *Accelerate* by Nicole Forsgren, Jez Humble, and Gene Kim (2018)
- *Team Topologies* by Matthew Skelton and Manuel Pais (2019)
- *Inspired* by Marty Cagan (2017)
- *Hackers & Painters* by Paul Graham (2004)

**Articles & Papers:**
- "The Influence of Organizational Structure on Software Quality" (Microsoft Research, 2008)
- "No Silver Bullet: Essence and Accidents of Software Engineering" by Fred Brooks (1986)
- Gloria Mark's research on interruption and attention at UC Irvine
- Various Harvard Business Review articles on team dynamics and productivity

**Modern Takes:**
- Will Larson's *Staff Engineer* blog and book on tech leadership
- Charity Majors (Honeycomb) on observability and team structure  
- The State of DevOps reports by DORA

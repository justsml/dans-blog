---
unlisted: true
title: "Quiz: Postgres Gotchas that Will Make You Question Everything"
subTitle: "Think you know PostgreSQL? These might surprise you!"
label: PostgreSQL
category: Quiz
subCategory: Database
date: 2024-01-08
modified: 2024-01-08
tags: [quiz, postgresql, sql, database, intermediate, advanced]
---

import Challenge from '../../../components/QuizUI/Challenge';
import QuizUI from '../../../components/QuizUI/QuizUI';

<p class="inset">PostgreSQL: Where even `SELECT 1;` can surprise you! üêò</p>

Ready to test your PostgreSQL knowledge? We'll cover identity columns, timestamps, numeric operations, sampling, and more - all through the lens of a school database system. Let's see if you can spot the gotchas that trip up even seasoned developers!

<QuizUI>

{/* What triggers a hash join? */}

<Challenge 
  client:load
  index={0}
  group="SQL Internals"
  title="Hash Join Triggers"
  options={[
    {text: 'WHERE A = 1 AND B = 2', isAnswer: true},
    {text: 'WHERE A = 1 OR B = 2'},
    {text: 'WHERE A = 1 AND B > 2'},
    {text: 'WHERE A = 1 HASH JOIN ON ...'}


<Challenge
  client:load
  index={0}
  group="Identity Columns"
  title="The Modern Way to Auto-Increment"
  options={[
    {text: 'id SERIAL PRIMARY KEY', },
    {text: 'id BIGSERIAL PRIMARY KEY', },
    {text: 'id BIGINT AUTO_INCREMENT()', },
    {text: 'id BIGINT AUTO_INCREMENT PRIMARY KEY'},
    {text: 'id BIGINT DEFAULT nextval(\'id_seq\') PRIMARY KEY'},
    {text: 'id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is the _ANSI SQL Standard_ compliant way to create an auto-incrementing primary key since PostgreSQL 10+?
    
    ```sql
    CREATE TABLE students (
      -- Which syntax? ü§î
      first_name TEXT NOT NULL,
      last_name TEXT NOT NULL
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    While `SERIAL`/`BIGSERIAL` is widely used, it's actually PostgreSQL-specific and considered legacy. The SQL Standard compliant way is:

    ```sql
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    ```

    I know, it rolls right off the tongue! ü§ì

    #### Why it's better:

    This syntax was introduced in PostgreSQL 10 and is preferred because:
    - It's SQL Standard compliant
    - Handles concurrent inserts more safely
    - Manages sequence ownership automatically
    - Works better with schema migrations
    
    `SERIAL` is still supported but may be deprecated in future versions.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={1}
  group="Timestamps"
  title="Timezone Troubles"
  options={[
    {text: 'time'},
    {text: 'timetz'},
    {text: 'timestamp', isAnswer: true},
    {text: 'timestamptz'},
    {text: 'datetime'},
    {text: 'datetimetz'}
  ]}
>
  <slot name="question">
  <div className="question">
    We need to store class schedules served across many timezones. Which data type most effectively handles this?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Why not `timestamptz`? Because it stores timezones at SAVE TIME. Using the server's time, or as specified by the input string.

    This isn't ideal for class schedules that need to be displayed in the local times BASED ON THE LOCATION WHEN/WHERE THEY'RE VIEWED.
    
    Instead, normalize all dates to UTC in SQL, then when displaying the date, use the browser locale to apply the correct format.

    `timestamp` is the best choice for storing class schedules because:
    - `time` only stores time of day.
    - `timetz` includes timezone but not date.
    - `timestamptz` includes timezone and date.
    - `datetime` is MySQL/MSSQL-specific.
    - `datetimetz` not a thing in PostgreSQL.

    Remember: Unless you need to keep and persist specific timezones with your dates. store timestamps in UTC and convert to local time for display!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Numeric Operations"
  title="Integer Overflow"
  options={[
    {text: '4294967296'},
    {text: '0'},
    {text: 'NULL'},
    {text: 'ERROR: integer out of range', isAnswer: true}
  ]}
>
  <slot name="question">
  <div className="question">
    What's the result of this query checking total possible student IDs?
    ```sql
    SELECT 256 * 256 * 256 * 256;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This calculation exceeds PostgreSQL's integer range (-2,147,483,648 to +2,147,483,647).

    To fix this, either:
    ```sql
    -- Use BIGINT
    SELECT 256::BIGINT * 256 * 256 * 256;
    
    -- Or use numeric
    SELECT 256::numeric * 256 * 256 * 256;
    ```

    Remember: Integer overflow in PostgreSQL throws an error, unlike some databases that silently wrap around!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={3}
  group="Aggregates"
  title="COUNT(*) Behavior"
  options={[
    {text: '0'},
    {text: '1', isAnswer: true},
    {text: 'NULL'},
    {text: 'Error: no rows returned'}
  ]}
>
  <slot name="question">
  <div className="question">
    What will this query return?
    ```sql
    SELECT COUNT(*) 
    FROM students 
    WHERE student_id < 0;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `COUNT(*)` always returns at least 0, even when no rows match.

    Key points:
    - `COUNT(*)` counts rows, including NULL values
    - `COUNT(column)` counts non-NULL values in that column
    - `COUNT(DISTINCT column)` counts unique non-NULL values
    
    Common gotcha: People often expect NULL when no rows match!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={4}
  group="Indexes"
  title="Multi-Column Index Order"
  options={[
    {text: 'CREATE INDEX idx_students ON students (last_name, first_name);', isAnswer: true},
    {text: 'CREATE INDEX idx_students ON students (first_name, last_name);'},
    {text: 'Both are equally efficient'},
    {text: 'Need separate indexes for each combination'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which index is more efficient for this common query pattern?
    ```sql
    -- Query 1: 
    SELECT * FROM students WHERE last_name = 'Smith';
    
    -- Query 2:
    SELECT * FROM students 
    WHERE last_name = 'Smith' AND first_name = 'John';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    The order of columns in a multi-column index matters! 

    Index on `(last_name, first_name)` can be used for:
    - `WHERE last_name = ?`
    - `WHERE last_name = ? AND first_name = ?`
    
    But index on `(first_name, last_name)` can only be used for:
    - `WHERE first_name = ?`
    - `WHERE first_name = ? AND last_name = ?`

    Think of it like a phone book - organized by last name first!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={5}
  group="Quoting"
  title="Column Name Quoting"
  options={[
    {text: 'first.name'},
    {text: '"first.name"', isAnswer: true},
    {text: '\'first.name\''},
    {text: '[first.name]'}
  ]}
>
  <slot name="question">
  <div className="question">
    How do you properly quote a column name containing a period?
    ```sql
    CREATE TABLE teachers (
      id INT GENERATED BY DEFAULT AS IDENTITY,
      _____ TEXT,  -- How to quote "first.name"?
      salary NUMERIC
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL uses double quotes for identifier quoting:
    - Double quotes `"..."` for identifiers
    - Single quotes `'...'` for string literals
    - Square brackets `[...]` are for SQL Server
    
    Without quotes, a period in a column name would be interpreted as a schema/table separator! Additionally, all unquoted identifiers are lower-cased by default.

    In order to reduce surprises, it's best to use `snake_case` and avoid using special characters.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={6}
  group="Sampling"
  title="Random Sampling"
  options={[
    {text: 'TABLESAMPLE USER (10)'},
    {text: 'SAMPLETABLE SYSTEM (10)'},
    {text: 'TABLESAMPLE SYSTEM (10)', isAnswer: true},
    {text: 'SAMPLE (10) FROM'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which is the correct syntax to sample approximately 10% of rows from a large students table?
    ```sql
    SELECT * 
    FROM students
    _______ -- Which sampling syntax?
    WHERE grade_level = 9;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `TABLESAMPLE SYSTEM (percent)` is the standard syntax.

    Important notes:
    - Percentage is approximate
    - `SYSTEM` uses block-level sampling
    - `BERNOULLI` is available for row-level sampling
    - `USER` sampling method doesn't exist
    - `SAMPLETABLE` is incorrect syntax
    
    Example:
    ```sql
    SELECT * FROM students 
    TABLESAMPLE SYSTEM (10)
    -- Samples ~10% of the table
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={7}
  group="Type Casting"
  title="Cast Syntax Variations"
  options={[
    {text: 'All are valid', isAnswer: true},
    {text: 'Only CAST() is valid'},
    {text: 'Only :: is valid'},
    {text: 'Only type() is valid'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these grade conversion syntaxes are valid?
    ```sql
    SELECT 
      CAST('95' AS INTEGER) as grade1,
      '95'::INTEGER as grade2,
      INTEGER '95' as grade3;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL supports three casting syntaxes:

    1. ANSI SQL: `CAST(expression AS type)`
    2. PostgreSQL: `expression::type`
    3. Type function: `type 'literal'`

    All are functionally equivalent, but:
    - `CAST()` is most portable
    - `::` is PostgreSQL-specific but commonly used
    - Type function style is least common
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={8}
  group="ANSI SQL"
  title="Standards Compliance"
  options={[
    {text: 'ILIKE'},
    {text: 'RETURNING', isAnswer: true},
    {text: 'WITH'},
    {text: 'LATERAL'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these PostgreSQL features is NOT part of the ANSI SQL standard?
    ```sql
    WITH new_student AS (
      INSERT INTO students (name, grade)
      VALUES ('Marcus Aurelius', 12)
      RETURNING *
    )
    SELECT * FROM new_student
    WHERE name ILIKE 'marc%';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL extensions to ANSI SQL:
    - `RETURNING` clause
    - `ILIKE` for case-insensitive matching
    - Array types and operations
    - JSON/JSONB types
    
    ANSI SQL standard includes:
    - `WITH` (Common Table Expressions)
    - `LATERAL` joins
    - Window functions
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Aggregate Functions"
  title="Built-in Aggregates"
  options={[
    {text: 'MIN'},
    {text: 'MAX'},
    {text: 'AVG'},
    {text: 'MEDIAN', isAnswer: true}
  ]}
>
  <slot name="question">
  <div className="question">
    Which is NOT a built-in aggregate function in PostgreSQL?
    ```sql
    SELECT 
      MIN(grade) as lowest,
      MAX(grade) as highest,
      AVG(grade) as average,
      MEDIAN(grade) as middle
    FROM grades;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `MEDIAN` is not built-in! You need:
    ```sql
    PERCENTILE_CONT(0.5) 
    WITHIN GROUP (ORDER BY grade)
    ```

    Common built-in aggregates:
    - `MIN`, `MAX`, `COUNT`
    - `AVG`, `SUM`
    - `ARRAY_AGG`, `STRING_AGG`
    - Various statistical functions
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={10}
  group="NULL Behavior"
  title="NULL in Comparisons"
  options={[
    {text: '10'},
    {text: '11'},
    {text: '12', isAnswer: true},
    {text: 'Error'}
  ]}
>
  <slot name="question">
  <div className="question">
    How many rows will this return?
    ```sql
    SELECT COUNT(*) FROM students
    WHERE grade_level <= 12 
      AND (gpa > 3.5 OR gpa IS NULL);
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This is tricky because:
    - `NULL` in comparisons (`>`, `<`, `=`) always returns `NULL`
    - `NULL` in boolean context is treated as `false`
    - `IS NULL` specifically checks for `NULL`
    
    So `gpa > 3.5 OR gpa IS NULL` includes:
    1. Students with GPA > 3.5
    2. Students with NULL GPA
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={11}
  group="Date/Time"
  title="Timestamp Precision"
  options={[
    {text: '2024-01-08 13:30:00+00'},
    {text: '2024-01-08 13:30:00.123456+00'},
    {text: '2024-01-08 13:30:00.123456789+00'},
    {text: '2024-01-08 13:30:00.123456', isAnswer: true}
  ]}
>
  <slot name="question">
  <div className="question">
    Which timestamp format exceeds PostgreSQL's maximum precision?
    ```sql
    CREATE TABLE class_sessions (
      id INT GENERATED BY DEFAULT AS IDENTITY,
      start_time timestamptz,
      end_time timestamptz
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL timestamps have microsecond (6 decimal places) precision.

    - Maximum: `.123456` (6 digits)
    - Nanoseconds (9 digits) are truncated
    - Timezone offset required for `timestamptz`
    
    Common gotcha: Some languages/frameworks send nanosecond precision that gets silently truncated!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={12}
  group="Constraints"
  title="Check Constraint Timing"
  options={[
    {text: 'Immediately'},
    {text: 'At transaction commit', isAnswer: true},
    {text: 'On next query'},
    {text: 'Never - constraints are only checked on INSERT'}
  ]}
>
  <slot name="question">
  <div className="question">
    When is this grade constraint checked?
    ```sql
    ALTER TABLE students 
    ADD CONSTRAINT valid_grade 
    CHECK (
      (grade >= 0 AND grade <= 100) OR 
      grade IS NULL
    ) NOT VALID;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `NOT VALID` constraints:
    - Are checked at transaction commit
    - Don't validate existing rows
    - Useful for large tables
    
    Without `NOT VALID`:
    - Constraint is checked immediately
    - All existing rows are validated
    - Can be slow on large tables
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={13}
  group="Performance"
  title="Index Only Scans"
  options={[
    {text: 'CREATE INDEX idx_names ON students(first_name, last_name);'},
    {text: 'CREATE INDEX idx_names ON students(last_name) INCLUDE (first_name);', isAnswer: true},
    {text: 'CREATE INDEX idx_names ON students(last_name, first_name) WHERE first_name IS NOT NULL;'},
    {text: 'Two separate indexes on first_name and last_name'}
  ]}
>
  <slot name="question">
  <div className="question">
    Which index best supports this query?
    ```sql
    SELECT first_name, last_name 
    FROM students 
    WHERE last_name LIKE 'A%'
    ORDER BY last_name;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `INCLUDE` columns enable index-only scans when:
    - All needed columns are in the index
    - Only included columns aren't used for sorting/filtering
    
    Benefits:
    - Smaller index (included columns only stored in leaf pages)
    - Better performance (no table lookups needed)
    - Perfect for covering indexes
    
    The compound index would work but be larger and less efficient.
  </div>
  </slot>
</Challenge>

</QuizUI>

Wow! That was a deep dive into PostgreSQL's quirks and features! üêò

Ready for more database fun? Check out my [Quiz Collection](/challenges/) for more brain-teasers!

Remember: In PostgreSQL, as in life, it's the edge cases that teach us the most! ü§ì


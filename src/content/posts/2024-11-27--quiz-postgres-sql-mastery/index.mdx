---
unlisted: true
title: "Quiz: The Impossible PostgreSQL Test"
subTitle: "Think you know Postgres? These might surprise you!"
label: PostgreSQL
category: Quiz
subCategory: Database
date: 2024-11-28
modified: 2024-11-28
tags: [quiz, postgresql, sql, database, intermediate, advanced]
cover_full_width: postgresql-elephant-wide.webp
cover_mobile: postgresql-elephant-square.webp
cover_icon: postgresql-elephant-square.webp
---
import Challenge from '../../../components/QuizUI/Challenge';
import QuizUI from '../../../components/QuizUI/QuizUI';

<p class="inset">PostgreSQL üêò Is easily my favorite Database.</p>

Over the years, I've learned a lot about its powerful features. Along the way, I've also discovered some quirks that can trip up even the most experienced developers.

Are you made out of **SQL Steele?** Or are you more of a **SQL Squish?** ü§î

This quiz covers a mix of familiar and lesser-known PostgreSQL features and gotchas, including:

- a cozy Warmup feat. JOINs,
- identity columns,
- handling timestamps/timezone,
- integer arithmetic,
- proper indexing.

<QuizUI>


<Challenge
  client:load
  index={0}
  group="Warmup: Joins"
  title="The Many JOINs of PostgreSQL"
  options={[
    {text: 'INNER JOIN'},
    {text: 'CROSS JOIN'},
    {text: 'JOIN ALL', isAnswer: true},
    {text: 'LEFT OUTER JOIN'},
    {text: 'FULL OUTER JOIN'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is not ‚ùå a valid PostgreSQL JOIN expression?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    You knew about `CROSS JOIN`, right?

    Did the `JOIN ALL` get you thinking about another valid operation, `UNION ALL`?

    The answer here is the invalid syntax `JOIN ALL`.

    The correct JOIN types are:
    - `INNER JOIN` (default JOIN)
    - `LEFT JOIN` (or `LEFT OUTER JOIN`)
    - `RIGHT JOIN` (or `RIGHT OUTER JOIN`)
    - `FULL JOIN` (or `FULL OUTER JOIN`)
    - `CROSS JOIN` (aka "The Self Join," aka "The Lonely JOIN," famously known-at-parties, the `Cartesian product`!)
  </div>
  </slot>
</Challenge>


<Challenge
  client:load
  index={1}
  group="Identity Columns"
  title="The Modern Way to Auto-Increment"
  options={[
    {text: 'id SERIAL PRIMARY KEY', },
    {text: 'id INTEGER AUTO_INCREMENT PRIMARY KEY'},
    {text: 'id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY', isAnswer: true},
    {text: 'id BIGSERIAL PRIMARY KEY'},
  ]}
>
  <slot name="question">
  <div className="question">
    What is the SQL Standard compliant way to create an auto-incrementing primary key in PostgreSQL 10+?
    
    We're creating a table to track students:
    ```sql
    CREATE TABLE students (
      -- Which syntax should we use here? ü§î
      name VARCHAR(100) NOT NULL
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    While `SERIAL` is still commonly used, the SQL Standard way is:
    ```sql
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
    ```

    This has several advantages over `SERIAL`:
    - It's SQL Standard compliant
    - Better handling of sequence ownership
    - Clearer semantics around manual inserts
    - Works better with replication
    
    `SERIAL` is actually just shorthand for creating a sequence and setting a default value, which can lead to issues with dumps and restores.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Timestamps"
  title="Timezone Troubles"
  options={[
    {text: '2024-01-07 15:30:00+00', isAnswer: true},
    {text: '2024-01-07 15:30:00'},
    {text: '2024-01-07 15:30:00+02'},
    {text: 'Error: timezone mismatch'},
  ]}
>
  <slot name="question">
  <div className="question">
    What will this query return?
    ```sql
    SET timezone = 'UTC';
    
    SELECT enrollment_date::timestamptz 
    FROM (
      VALUES ('2024-01-07 15:30:00'::timestamp)
    ) AS t(enrollment_date);
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">

  ## TODO

  </div>
  </slot>
</Challenge>

# Dizzying Types

I'm sure you've used *so many* types in SQL, right?

The next 5 questions are about Postgres' (17) native types - almost all of them!

For each question identify the **one invalid type**. üïµÔ∏è‚Äç‚ôÇÔ∏è

<p class="inset">Onward!</p>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'VARCHAR(100)'},
    {text: 'CHAR(100)'},
    {text: 'TEXT'},
    {text: 'STRING(100)', isAnswer: true},
    {text: 'CHARACTER VARYING(100)'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL has a rich set of data types, but `STRING(100)` is not one of them.

    The correct string types include:
    - `VARCHAR(100)` (variable-length string)
    - `CHAR(100)` (fixed-length string)
    - `TEXT` (unlimited length)
    - `CHARACTER VARYING(100)` (same as `VARCHAR(100)`)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'int'},
    {text: 'real'},
    {text: 'bigint'},
    {text: 'bigserial'},
    {text: 'smallserial'},
    {text: 'decimal128', isAnswer: true},
    {text: 'double precision'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    It may seem familiar since `decimal128` is a type in many places (including Mongo and Java.) It's not a valid PostgreSQL type, `decimal` is.

    The correct numeric types include:
    - `int` (4-byte integer)
    - `bigint` (8-byte integer)
    - `real` (4-byte floating-point)
    - `double precision` (8-byte floating-point)
    - `bigserial` (auto-incrementing 8-byte integer)
    - `smallserial` (auto-incrementing 2-byte integer)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'cidr'},
    {text: 'inet'},
    {text: 'ipv4', isAnswer: true},
    {text: 'macaddr'},
    {text: 'macaddr8'},
    {text: 'interval'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Did this make you frustrated, even _angry_? You're not alone! To quote an unnamed "core" database contributor buddy, "what the hell, Dan?! I crashed on the type questions! Thats violent sir! Not sharing my score, hah." üòà You're welcome.

    PostgreSQL's rich set of network types do not include `ipv4`.
    
    You'd want to use the `inet` type for IP addresses, which I swear I've never had to Google. üëÄ

    The correct network types include:
    - `cidr` (IPv4/IPv6 network address)
    - `inet` (IPv4/IPv6 host address)
    - `ipv4` (IPv4 host address)
    - `macaddr` (MAC address)
    - `macaddr8` (EUI-64 MAC address)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'lseg'},
    {text: 'bytea'},
    {text: 'tsquery'},
    {text: 'tsvector'},
    {text: 'tsrank', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL has a rich set of geometric and text search types, but `tsrank` is not one of them.

    The correct geometric and text search types include:
    - `lseg` (line segment)
    - `txid` (transaction ID)
    - `bytea` (binary data)
    - `tsquery` (text search query)
    - `tsvector` (text search document)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'xml'},
    {text: 'uuid'},
    {text: 'money'},
    {text: 'currency', isAnswer: true},
    {text: 'interval'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL has a rich set of specialized types, but `triangle` is not one of them.

    The correct specialized types include:
    - `xml` (XML data)
    - `uuid` (UUID)
    - `money` (currency amount)
    - `currency` (currency symbol)
    - `interval` (time interval)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Postgres Types"
  title="Identify Invalid Types"
  options={[
    {text: 'box'},
    {text: 'line'},
    {text: 'point'},
    {text: 'circle'},
    {text: 'polygon'},
    {text: 'triangle', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which of these is not ‚ùå a valid PostgreSQL type?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL has a rich set of specialized types, but `triangle` is not one of them.

    The correct specialized types include:
    - `box` (rectangular box)
    - `line` (infinite line)
    - `point` (2D point)
    - `circle` (2D circle)
    - `polygon` (2D polygon)
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={3}
  group="Integer Arithmetic"
  title="Integer Overflow"
  options={[
    {text: '4294967296'},
    {text: 'Error: integer out of range', isAnswer: true},
    {text: '0'},
    {text: '2147483647'},
  ]}
>
  <slot name="question">
  <div className="question">
    What happens when calculating total possible student IDs?
    ```sql
    SELECT 256 * 256 * 256 * 256;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL's `integer` type is 32-bit signed, ranging from -2,147,483,648 to 2,147,483,647.

    The calculation 256^4 = 4,294,967,296 exceeds this range.

    To handle larger numbers:
    ```sql
    -- Use BIGINT
    SELECT 256::bigint * 256 * 256 * 256;
    
    -- Or numeric for arbitrary precision
    SELECT 256::numeric * 256 * 256 * 256;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={4}
  group="COUNT Behavior"
  title="COUNT(*) vs COUNT(column)"
  options={[
    {text: 'They are identical'},
    {text: 'COUNT(*) is faster', isAnswer: true},
    {text: 'COUNT(column) is faster'},
    {text: 'Depends on the number of NULL values'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is more efficient for counting students?
    ```sql
    SELECT COUNT(*) FROM students;
    -- vs
    SELECT COUNT(id) FROM students;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `COUNT(*)` is optimized to count rows without checking column values.
    
    Postgres can't always optimize `COUNT(*)` since it doesn't need to check for NULL values.

    `COUNT(column)` must check each value for NULL, making it slower.

    Best practices:
    - Use `COUNT(*)` for row counts
    - Use `COUNT(column)` only when you specifically need to count non-NULL values
    
    This is especially important for large tables!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={5}
  group="Indexing"
  title="Multi-Column Index Order"
  options={[
    {text: 'CREATE INDEX ON students.grade_level;\nCREATE ... students.last_name;'},
    {text: 'CREATE INDEX ON students(grade_level, last_name);', isAnswer: true},
    {text: 'CREATE INDEX ON students(grade_level);'},
    {text: 'CREATE INDEX ON students(last_name, grade_level);'},
    {text: 'CREATE INDEX ON students(first_name, last_name, grade_level);'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which index is better for this query?
    ```sql
    -- Query:
    SELECT * FROM students 
    WHERE grade_level = 9 
      AND last_name LIKE 'Smith%';

    -- Index A:
    
    -- Index B:
    CREATE INDEX ON students(last_name, grade_level);
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Put the most selective column first in multi-column indexes.

    The index can be used for:
    - All columns
    - Left-most columns only
    
    If `last_name LIKE 'Smith%'` is more selective than `grade_level = 9`, Index B would be more efficient.

    Consider query patterns and column cardinality when designing indexes!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={6}
  group="Column Names"
  title="Proper Quoting"
  options={[
    {text: 'Both work the same'},
    {text: 'Double quotes are required', isAnswer: true},
    {text: 'Single quotes are required'},
    {text: 'Neither will work'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is correct for case-sensitive column names?
    ```sql
    CREATE TABLE grades (
      "Student Name" VARCHAR(100),
      'Student Grade' INTEGER
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    In PostgreSQL:
    - Double quotes (`"`) are for identifiers (table names, column names)
    - Single quotes (`'`) are for string literals
    
    Best practices:
    - Avoid mixed case or spaces in names
    - Use snake_case for identifiers
    - Only use quoted identifiers when absolutely necessary
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={5}
  group="Quoting 2"
  title="Column Name Quoting"
  options={[
    {text: 'first.name'},
    {text: '"first.name"', isAnswer: true},
    {text: '\'first.name\''},
    {text: '[first.name]'},
    {text: '[first].[name]'},
  ]}
>
  <slot name="question">
  <div className="question">
    How do you properly quote a column name containing a period?
    ```sql
    CREATE TABLE teachers (
      id INT GENERATED BY DEFAULT AS IDENTITY,
      _____ TEXT,  -- How to quote "first.name"?
      salary NUMERIC
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL uses double quotes for identifier quoting:
    - Double quotes `"..."` for identifiers
    - Single quotes `'...'` for string literals
    - Square brackets `[...]` are for SQL Server
    
    Without quotes, a period in a column name would be interpreted as a schema/table separator! Additionally, all unquoted identifiers are lower-cased by default.

    In order to reduce surprises, it's best to use `snake_case` and avoid using special characters.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={7}
  group="Random Sampling"
  title="TABLESAMPLE Syntax"
  options={[
    {text: '...students SAMPLETABLE BERNOULLI (0.10)'},
    {text: '...students TABLESAMPLE USER (10)'},
    {text: '...students TABLESAMPLE RANDOM (10)'},
    {text: '...students SAMPLE 10 PERCENT'},
    {text: 'ROW_NUMBER() OVER (ORDER BY RAND())'},
    {text: 'ORDER BY RANDOM() > 10'},
    {text: 'WHERE RANDOM() > 0.1', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is the valid syntax to **randomly sample 10%** of students?
    ```sql
    SELECT * FROM students
    -- Which syntax will you need? ü§î
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This one is tricky! It features roughly 6 traps, some include:

    1. High level description + fragments of syntax. Tests how you adapt & assemble incomplete info.
    2. Requires familiar knowledge of `TABLESAMPLE` syntax, since none of the `TABLESAMPLE` options use the correct syntax! (Sinister! I know! Keep going, I believe in you!!! ‚ù§Ô∏è)
    3. The `ROW_NUMBER() OVER (ORDER BY RAND())` and `ORDER BY RANDOM() > 10` are more red herrings. They look like they could be correct, but they're not. `RAND()` isn't a thing. And `RANDOM() > 10` is a boolean expression that will always be false since `RANDOM()` always is in the range `0.0-1.0`.
    One more problem, the `ORDER BY RANDOM() > 10` would also sort on a boolean value, not a random number. But that `> 10` sure felt like it could be a percentage, right?

    As for the `TABLESAMPLE` method, PostgreSQL supports two sampling methods:
    - `BERNOULLI`: Each row has equal probability
    - `SYSTEM`: Block-level sampling (faster but less random)
    
    Example:
    ```sql
    -- Sample 10% of rows
    SELECT * FROM students TABLESAMPLE BERNOULLI (10);
    
    -- For repeatable results, use REPEATABLE:
    SELECT * FROM students 
    TABLESAMPLE BERNOULLI (10) REPEATABLE (42);
    ```

    Also worth mentioning, `TABLESAMPLE` [has been reported](https://stackoverflow.com/questions/8674718/best-way-to-select-random-rows-postgresql) to not be very random. If you need a _more_ random sample, consider using `ORDER BY RANDOM() LIMIT 10`. But be aware that this can be slow on large tables.

    There are also some third-party extensions that provide better random sampling methods, but that's out of scope for this! üòÖ
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={8}
  group="Timestamps"
  title="timestamptz vs timestamp"
  options={[
    {text: 'They store the same data differently'},
    {text: 'timestamptz stores more data', isAnswer: true},
    {text: 'timestamp stores more data'},
    {text: 'They are aliases of each other'},
  ]}
>
  <slot name="question">
  <div className="question">
    For storing class schedule times, what's the difference?
    ```sql
    CREATE TABLE classes (
      starts_at timestamp,
      ends_at timestamptz
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">

  ## TODO

  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Indexing"
  title="Partial Indexes"
  options={[
    {text: 'Invalid syntax'},
    {text: 'Creates duplicate indexes'},
    {text: 'Only indexes active students', isAnswer: true},
    {text: 'Indexes active students first'},
    {text: 'Provides a hint to the query planner'},
  ]}
>
  <slot name="question">
  <div className="question">
    What does this incantation do?
    ```sql
    CREATE INDEX idx_active_students 
    ON students(last_name) 
    WHERE status = 'active';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This is a valid `Partial Index`. They are useful for reducing disk use & speeding queries when only a subset of rows are typically queried.

    Benefits:
    - Smaller index size.
    - Faster create/vacuum/maintenance operations.
    - Better query performance for matching conditions.
    
    Great for tables where:
    - You frequently query a subset of rows.
    - The subset is a bit smaller than the whole table.

    Postgres will only use the index when the `status = 'active'` condition is present in the query.

    **Reminder:** Postgres doesn't support 'query hints' like other RDBMSs. The query planner will decide when to use any appropriate index(es).
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Index Usage"
  title="Index Usage"
  options={[
    {text: 'Invalid syntax'},
    {text: 'Creates duplicate indexes'},
    {text: 'Only indexes active students', isAnswer: true},
    {text: 'Indexes active students first'},
    {text: 'Provides a hint to the query planner'},
  ]}
>
  <slot name="question">
  <div className="question">
    What does this incantation do?
    ```sql
    CREATE INDEX idx_active_students 
    ON students(last_name) 
    WHERE status = 'active';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This is a valid `Partial Index`. They are useful for reducing disk usage when only a subset of rows are typically queried.

    Benefits:
    - Smaller index size.
    - Faster create/vacuum/maintenance operations.
    - Better query performance for matching conditions.
    
    Great for tables where:
    - You frequently query a subset of rows.
    - The subset is a bit smaller than the whole table.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={10}
  group="NULL Behavior"
  title="COUNT and NULL"
  options={[
    {text: '100'},
    {text: '90'},
    {text: '10'},
    {text: '0', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    How many rows will this return?
    ```sql
    SELECT COUNT(*) 
    FROM students 
    WHERE grade IS NULL 
      AND grade = NULL;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    This returns 0 because:
    1. `NULL = NULL` is never true
    2. Use `IS NULL` or `IS NOT NULL` to check for NULL values
    
    Correct query would be:
    ```sql
    SELECT COUNT(*) 
    FROM students 
    WHERE grade IS NULL;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={11}
  group="Constraints"
  title="UNIQUE Constraints and NULL"
  options={[
    {text: 'Only one NULL allowed', },
    {text: 'No NULLs allowed'},
    {text: 'Multiple NULLs allowed', isAnswer: true},
    {text: 'Depends on PostgreSQL version'},
  ]}
>
  <slot name="question">
  <div className="question">
    How many NULL values are allowed here?
    ```sql
    CREATE TABLE student_emails (
      student_id INTEGER,
      email VARCHAR(255),
      UNIQUE(email)
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    UNIQUE constraints in PostgreSQL:
    - Allow multiple NULL values
    - NULL ‚â† NULL in uniqueness checks
    
    To prevent NULL values, add NOT NULL:
    ```sql
    CREATE TABLE student_emails (
      student_id INTEGER,
      email VARCHAR(255) NOT NULL,
      UNIQUE(email)
    );
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={12}
  group="Date/Time"
  title="Date Arithmetic"
  options={[
    {text: '2024-01-08'},
    {text: '2024-01-07 24:00:00', isAnswer: true},
    {text: 'Error: invalid time'},
    {text: '2024-01-08 00:00:00'},
  ]}
>
  <slot name="question">
  <div className="question">
    What does this return?
    ```sql
    SELECT '2024-01-07'::date + interval '24 hours';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL represents times up to '24:00:00' for a given date.

    These are equivalent:
    ```sql
    '2024-01-07 24:00:00'
    '2024-01-08 00:00:00'
    ```
    
    But they might display differently depending on context!
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={13}
  group="Performance"
  title="EXPLAIN ANALYZE Gotcha"
  options={[
    {text: 'Shows theoretical plan'},
    {text: 'Shows actual execution'},
    {text: 'Actually modifies data', isAnswer: true},
    {text: 'Only works on SELECT'},
  ]}
>
  <slot name="question">
  <div className="question">
    What happens with this query?
    ```sql
    EXPLAIN ANALYZE
    UPDATE students 
    SET grade = grade + 1 
    WHERE status = 'active';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `EXPLAIN ANALYZE` actually executes the query!
    
    Best practices:
    - Use `EXPLAIN` (without ANALYZE) for UPDATE/DELETE/INSERT
    - Wrap modifications in transactions:
    ```sql
    BEGIN;
    EXPLAIN ANALYZE ...;
    ROLLBACK;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={14}
  group="Transactions"
  title="Automatic Rollback"
  options={[
    {text: 'Commits all successful statements'},
    {text: 'Rolls back all statements', isAnswer: true},
    {text: 'Commits first statement only'},
    {text: 'Depends on isolation level'},
  ]}
>
  <slot name="question">
  <div className="question">
    What happens after an error?
    ```sql
    BEGIN;
    UPDATE students SET status = 'alumni' WHERE grade = 12;
    UPDATE students SET graduation_date = CURRENT_DATE WHERE grade = 12;
    UPDATE students SET grade = 'GRADUATED'; -- Error: type mismatch
    COMMIT;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    When an error occurs:
    - The entire transaction is rolled back
    - No changes are committed
    - The transaction is marked as failed
    
    To partially commit:
    ```sql
    BEGIN;
    UPDATE ...;
    SAVEPOINT my_save;
    UPDATE ...; -- Error
    ROLLBACK TO my_save;
    COMMIT;
    ```
  </div>
  </slot>
</Challenge>

</QuizUI>

Whew! That was a lot of PostgreSQL knowledge! üêò

I hope you learned something new about handling timestamps, indexes, and other PostgreSQL gotchas.

Want more database challenges? Check out my [Quiz Collection](/challenges/) for more SQL fun!

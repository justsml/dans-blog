---
unlisted: true
title: "Quiz: PostgreSQL 20 Questions - Mean Girls Edition"
subTitle: "On Wednesdays, we query in pink! ðŸ’…"
label: PostgreSQL
category: Quiz
subCategory: Database
date: 2024-11-27
modified: 2024-11-27
tags: [quiz, postgresql, sql, database, intermediate, advanced]
---
{/* cover_full_width: mean-girls-cafeteria.webp
cover_mobile: mean-girls-cafeteria-square.webp
cover_icon: mean-girls-cafeteria-square.webp */}
import Challenge from '../../../components/QuizUI/Challenge';
import QuizUI from '../../../components/QuizUI/QuizUI';

<p class="inset">Get in loser, we're going querying! ðŸ’…</p>

Think you know your way around PostgreSQL? Let's test your knowledge of some common gotchas and best practices. From identity columns to timestamps, from `COUNT(*)` behavior to proper indexing - we'll cover it all!

If you haven't seen _Mean Girls_

<QuizUI>

<Challenge
  client:load
  index={0}
  group="Identity Columns"
  title="The Standard Way"
  options={[
    {text: 'id SERIAL PRIMARY KEY'},
    {text: 'id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY', isAnswer: true},
    {text: 'id INT AUTO_INCREMENT PRIMARY KEY'},
    {text: 'id BIGSERIAL PRIMARY KEY'},
  ]}
>
  <slot name="question">
  <div className="question">
    What is the SQL Standard compliant way to create an auto-incrementing primary key in PostgreSQL for the `students` table?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    While `SERIAL` is commonly used in PostgreSQL, it's actually a non-standard implementation. The SQL Standard way is:
    ```sql
    CREATE TABLE students (
      id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name VARCHAR(100)
    );
    ```
    
    `SERIAL` is PostgreSQL-specific and internally creates a sequence. The `GENERATED BY DEFAULT AS IDENTITY` syntax was introduced in PostgreSQL 10 and is the preferred, standard-compliant way.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={1}
  group="Timestamps"
  title="Timezone Troubles"
  options={[
    {text: 'Both store timezone, but TIMESTAMPTZ uses UTC internally'},
    {text: 'Neither stores timezone information'},
    {text: 'TIMESTAMP stores timezone, TIMESTAMPTZ does not'},
    {text: 'TIMESTAMPTZ stores timezone, TIMESTAMP does not', isAnswer: true},
  ]}
>
  <slot name="question">
  <div className="question">
    What's the difference between `TIMESTAMP` and `TIMESTAMPTZ` when storing Regina George's party time?
    ```sql
    CREATE TABLE parties (
      event_time TIMESTAMP,
      event_time_tz TIMESTAMPTZ
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    - `TIMESTAMP` stores the exact datetime without timezone information
    - `TIMESTAMPTZ` stores datetime in UTC internally and converts to the session timezone on display
    
    ```sql
    -- These behave differently:
    INSERT INTO parties VALUES 
    ('2024-01-09 15:00:00', '2024-01-09 15:00:00');
    
    SET timezone = 'America/New_York';
    SELECT * FROM parties; -- TIMESTAMPTZ will adjust!
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={2}
  group="Integer Overflow"
  title="Math Class"
  options={[
    {text: '4294967296'},
    {text: 'Error: integer out of range', isAnswer: true},
    {text: '0'},
    {text: '65536'},
  ]}
>
  <slot name="question">
  <div className="question">
    What will this query return in Mr. Duvall's math class?
    ```sql
    SELECT 256 * 256 * 256 * 256;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL's `integer` type is 4 bytes and can store values from -2,147,483,648 to +2,147,483,647.

    256^4 = 4,294,967,296 which exceeds this range.

    To fix this, use `bigint`:
    ```sql
    SELECT 256::bigint * 256 * 256 * 256;
    ```
    
    Or use numeric:
    ```sql
    SELECT 256::numeric * 256 * 256 * 256;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={3}
  group="COUNT Behavior"
  title="Counting Students"
  options={[
    {text: 'COUNT(*) is faster', isAnswer: true},
    {text: 'COUNT(column) is faster'},
    {text: 'They have identical performance'},
    {text: 'It depends on the index'},
  ]}
>
  <slot name="question">
  <div className="question">
    When counting students in North Shore High, which is more efficient?
    ```sql
    SELECT COUNT(*) FROM students;
    -- vs
    SELECT COUNT(student_id) FROM students;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `COUNT(*)` is optimized to count rows without checking column values.
    
    `COUNT(column)` must check each value to exclude NULLs.
    
    Even with a NOT NULL column, `COUNT(*)` is typically faster as it's specifically optimized by PostgreSQL.
    
    ```sql
    EXPLAIN ANALYZE SELECT COUNT(*) FROM students;
    -- vs
    EXPLAIN ANALYZE SELECT COUNT(student_id) FROM students;
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={4}
  group="Indexing"
  title="Multi-Column Index Order"
  options={[
    {text: 'CREATE INDEX idx_students ON students (grade, name)'},
    {text: 'CREATE INDEX idx_students ON students (name, grade)', isAnswer: true},
    {text: 'Both are equally effective'},
    {text: 'Neither will be effective'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which index is better for this query?
    ```sql
    SELECT * FROM students 
    WHERE name LIKE 'G%' 
    AND grade = 11;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    Column order in multi-column indexes matters! The index should match the most selective column first.
    
    In this case, `name LIKE 'G%'` is likely more selective than `grade = 11`, so putting `name` first allows PostgreSQL to efficiently filter the results.
    
    The index can still be used for queries that only reference the leading column (`name`), but not for queries that only reference `grade`.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={5}
  group="Column Names"
  title="Quoting Identifiers"
  options={[
    {text: 'first name'},
    {text: '"first name"', isAnswer: true},
    {text: "'first name'"},
    {text: '[first name]'},
  ]}
>
  <slot name="question">
  <div className="question">
    How should you properly quote a column name containing a space in PostgreSQL?
    ```sql
    CREATE TABLE students (
      ??? VARCHAR(100)
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    - Double quotes `"` are for identifiers (table names, column names)
    - Single quotes `'` are for string literals
    - Square brackets `[]` are for SQL Server, not PostgreSQL
    
    Best practice: Avoid spaces in identifiers, use underscores instead:
    ```sql
    CREATE TABLE students (
      first_name VARCHAR(100)  -- Better!
    );
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={6}
  group="Random Sampling"
  title="Table Sampling"
  options={[
    {text: 'TABLESAMPLE BERNOULLI (10)', isAnswer: true},
    {text: 'TABLESAMPLE USER (10)'},
    {text: 'RANDOM() LIMIT 10'},
    {text: 'SAMPLE 10 PERCENT'},
  ]}
>
  <slot name="question">
  <div className="question">
    How do you properly select a random 10% sample of the cafeteria seating chart?
    ```sql
    SELECT * FROM seating_chart
    ??? ;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL supports two sampling methods:
    - `BERNOULLI`: Scans all rows but only returns sample percentage
    - `SYSTEM`: Samples pages, faster but less random
    
    ```sql
    -- Correct sampling:
    SELECT * FROM seating_chart
    TABLESAMPLE BERNOULLI (10);
    
    -- For exact row count:
    SELECT * FROM seating_chart
    TABLESAMPLE BERNOULLI (10)
    REPEATABLE (42);  -- Seed for reproducibility
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={7}
  group="Data Types"
  title="Temporal Types"
  options={[
    {text: 'timestamp', isAnswer: true},
    {text: 'datetime'},
    {text: 'datetimetz'},
    {text: 'time with timezone'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which is a valid PostgreSQL data type for storing when Cady moved from Africa?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    PostgreSQL's temporal types:
    - `timestamp` / `timestamp without time zone`
    - `timestamptz` / `timestamp with time zone`
    - `date`
    - `time` / `time without time zone`
    - `timetz` / `time with time zone`
    
    `datetime` and `datetimetz` are SQL Server types, not PostgreSQL.
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={8}
  group="NULL Behavior"
  title="Counting NULLs"
  options={[
    {text: '3'},
    {text: '4'},
    {text: '2', isAnswer: true},
    {text: '0'},
  ]}
>
  <slot name="question">
  <div className="question">
    How many rows will this return?
    ```sql
    CREATE TABLE burn_book (
      id int,
      gossip text
    );
    
    INSERT INTO burn_book VALUES
    (1, 'Made out with a hotdog'),
    (2, NULL),
    (3, NULL),
    (4, 'Still wears army pants');
    
    SELECT COUNT(gossip) FROM burn_book;
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    `COUNT(column)` only counts non-NULL values.
    
    To count all rows including NULLs, use:
    ```sql
    SELECT COUNT(*) FROM burn_book;  -- Returns 4
    ```
    
    To count only NULLs:
    ```sql
    SELECT COUNT(*) - COUNT(gossip) FROM burn_book;  -- Returns 2
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={9}
  group="Constraints"
  title="Identity Columns"
  options={[
    {text: 'Sequence will skip the value 100'},
    {text: 'Error: duplicate key value', isAnswer: true},
    {text: 'Will insert with id=100'},
    {text: 'Will auto-increment to 101'},
  ]}
>
  <slot name="question">
  <div className="question">
    What happens with this sequence of operations?
    ```sql
    CREATE TABLE spring_fling (
      id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      event_name text
    );
    
    INSERT INTO spring_fling (id, event_name)
    VALUES (100, 'Dance');
    
    INSERT INTO spring_fling (event_name)
    VALUES ('After Party');
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    When you explicitly insert a value into an IDENTITY column:
    1. The sequence is not automatically updated
    2. Next auto-generated value will try to use 1
    3. This causes a unique constraint violation
    
    To fix, use:
    ```sql
    SELECT setval(
      pg_get_serial_sequence('spring_fling', 'id'),
      100
    );
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={10}
  group="Performance"
  title="Index Only Scans"
  options={[
    {text: 'Index scan'},
    {text: 'Index only scan', isAnswer: true},
    {text: 'Sequential scan'},
    {text: 'Bitmap heap scan'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which scan type will PostgreSQL use for this query with an index on (name, grade)?
    ```sql
    CREATE INDEX idx_students ON students (name, grade);
    
    SELECT name, grade 
    FROM students 
    WHERE name = 'Regina George';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    An index only scan is possible because:
    1. All required columns (name, grade) are in the index
    2. No other columns are needed
    3. The WHERE clause uses the index columns
    
    This is the most efficient scan type as it never needs to visit the table's heap pages.
    
    Verify with:
    ```sql
    EXPLAIN ANALYZE SELECT name, grade 
    FROM students 
    WHERE name = 'Regina George';
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={11}
  group="Data Types"
  title="Numeric Precision"
  options={[
    {text: 'DECIMAL(10,2)'},
    {text: 'NUMERIC(10,2)'},
    {text: 'Both A and B', isAnswer: true},
    {text: 'Neither'},
  ]}
>
  <slot name="question">
  <div className="question">
    Which type(s) can safely store Ms. Norbury's salary to two decimal places?
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    In PostgreSQL:
    - `DECIMAL` and `NUMERIC` are exactly the same type
    - Both store exact values with specified precision
    - Format is: `NUMERIC(precision, scale)`
      - precision: total digits
      - scale: decimal places
    
    ```sql
    CREATE TABLE teachers (
      name TEXT,
      salary NUMERIC(10,2)  -- Up to 99999999.99
    );
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={12}
  group="Constraints"
  title="Check Constraints"
  options={[
    {text: 'CHECK (grade >= 9 AND grade <= 12)'},
    {text: 'CHECK (grade BETWEEN 9 AND 12)', isAnswer: true},
    {text: 'CHECK grade IN (9,10,11,12)'},
    {text: 'All of the above'},
  ]}
>
  <slot name="question">
  <div className="question">
    What's the most readable way to ensure students are in grades 9-12?
    ```sql
    CREATE TABLE students (
      name TEXT,
      grade INTEGER
      ??? 
    );
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    All options work, but `BETWEEN` is most readable for ranges.
    
    ```sql
    -- Best practice:
    CHECK (grade BETWEEN 9 AND 12)
    
    -- For discrete values, use IN:
    CHECK (grade IN (9,10,11,12))
    
    -- For complex conditions:
    CHECK (grade >= 9 AND grade <= 12)
    ```
  </div>
  </slot>
</Challenge>

<Challenge
  client:load
  index={13}
  group="Indexing"
  title="Partial Indexes"
  options={[
    {text: 'Regular index on (name)'},
    {text: 'Partial index on active students', isAnswer: true},
    {text: 'Multi-column index (name, active)'},
    {text: 'No index needed'},
  ]}
>
  <slot name="question">
  <div className="question">
    What's the most efficient index for this common query?
    ```sql
    CREATE TABLE students (
      name TEXT,
      active BOOLEAN DEFAULT true
    );
    
    -- Common query:
    SELECT * FROM students 
    WHERE active = true 
    AND name LIKE 'G%';
    ```
  </div>
  </slot>

  <slot name='explanation'>
  <div className="explanation">
    A partial index is most efficient when:
    1. You frequently query a subset of rows
    2. That subset is significantly smaller
    
    ```sql
    CREATE INDEX idx_active_students 
    ON students (name) 
    WHERE active = true;
    ```
    
    This index:
    - Only includes active students
    - Takes less space
    - Faster to scan
    - Perfect for this query pattern
  </div>
  </slot>
</Challenge>

</QuizUI>

That was so fetch! ðŸ’… 

Want more database challenges? Check out my [Quiz Collection](/challenges/) for more SQL shenanigans!

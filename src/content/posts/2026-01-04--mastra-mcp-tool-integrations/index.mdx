---
title: "Your AI Agent is Useless Without This"
subTitle: "Why MCP is the USB-C of Artificial Intelligence."
date: 2026-01-04
modified: 2026-01-08
tags: [AI, MCP, Tools, Integrations, Mastra, Salesforce, APIs]
category: AI
subCategory: Integration
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
---

> [!NOTE]
> **Mastra v1 Beta**
>
> This article uses the Mastra v1 Beta. The APIs have been updated since the initial alpha release. Please refer to the [Mastra v1 Migration Guide](https://mastra.ai/guides/v1/migrations/upgrade-to-v1/overview) and [Getting Started Docs](https://mastra.ai/docs/home) for the latest information.

You've built an AI agent. Maybe it's even a good one. The prompts are tight, the model is fast, and the responses feel natural.

But then someone asks it to check Salesforce for a customer record. Or pull the latest Jira tickets. Or search your internal documentation.

And your beautiful agent just... can't.

This is the integration problem that every AI platform eventually hits. Your agent needs hands. It needs eyes into your actual business systems. Without them, you're just running an expensive chatbot.

The traditional solution? Write a custom API wrapper for every single service you want to connect. Read their docs, handle their auth, deal with their rate limits, pray they don't change their endpoints next month. Then do it again for the next service. And the next.

The Model Context Protocol changes this calculus entirely.

---

## What MCP Actually Solves

Think about USB before USB-C. You had Mini-USB, Micro-USB, proprietary Apple connectors, and a drawer full of cables that only worked with specific devices. USB-C didn't just add a new connector—it established a standard that meant any cable could work with any device.

MCP is doing the same thing for AI tool integrations.

Instead of writing custom code to connect your agent to Salesforce, HubSpot, GitHub, or any other service, you implement the protocol once (or download a pre-built server), and any MCP-compatible agent can talk to it immediately.

The protocol handles the communication layer. You just define what your tools do and what data they need.

---

## Setting Up Multiple Integrations

Mastra has native MCP support through its [`MCPClient`](https://mastra.ai/docs/mcp/overview). You can connect both local tools (running as child processes) and remote services (running on their own infrastructure).

Here's a realistic production setup connecting Wikipedia search locally, plus remote Salesforce and HubSpot instances:

```typescript
// src/mastra/mcp/index.ts
import { MCPClient } from '@mastra/mcp';

export const mcpClient = new MCPClient({
  servers: {
    // Local tool (Stdio)
    wikipedia: {
      command: 'npx',
      args: ['-y', 'wikipedia-mcp'],
    },
    // Enterprise tool (Remote/HTTP)
    salesforce: {
      url: new URL(process.env.SALESFORCE_MCP_URL!),
      requestInit: {
        headers: {
          Authorization: `Bearer ${process.env.SALESFORCE_TOKEN}`,
        },
      },
    },
    // SaaS Integration
    hubspot: {
      url: new URL('https://mcp.composio.dev/hubspot/xyz'),
    },
  },
});
```

The client manages the connection lifecycle, handles process spawning for local tools, and maintains HTTP connections for remote servers. You don't touch sockets or stdio directly.

---

## Connecting Tools to Agents

Once you have your MCP client configured, giving those tools to an agent is straightforward:

```typescript
// src/mastra/agents/crm-agent.ts
import { Agent } from '@mastra/core/agent';
import { openai } from '@ai-sdk/openai';
import { mcpClient } from '../mcp';

export const weatherAgent = new Agent({
  id: 'weather-agent',
  name: 'Weather Agent',
  instructions: `You are a helpful weather assistant that provides accurate weather information.
    - Always ask for a location if none is provided
    - Use the weatherTool to fetch current weather data
    - Include relevant details like humidity, wind conditions, and precipitation
    - Keep responses concise but informative`,
  model: openai('gpt-5'),
  tools: { weatherTool },
});

export const crmAgent = new Agent({
  id: 'crm-agent',
  name: 'CRM Assistant',
  instructions: `You help sales teams manage deals.
    - Check Salesforce before answering
    - Verify customer data
    - Be concise`,
  model: openai('gpt-5'),
  tools: await mcpClient.getTools(), // <--- This is the magic line
});
```

When a user asks: *"What is the status of the Acme Corp deal?"*

The agent reads the available tool definitions, realizes it has access to a Salesforce lookup tool, executes it with the right parameters, and answers with actual data from your CRM.

You didn't write a single line of Salesforce API code.

---

## Per-User Authentication

There's a security mistake that's easy to make here: hardcoding credentials.

If you put one Salesforce token in your environment variables and call it a day, every user who talks to your agent is effectively acting as you. They see your data. They can modify your records. This works fine for demos. It's a liability in production.

Mastra handles this by letting you create MCP clients dynamically with user-specific credentials:

```typescript
async function handleUserRequest(userPrompt: string, userCredentials: UserCreds) {
  // Create a client for THIS specific user
  const userMcp = new MCPClient({
    servers: {
      salesforce: {
        url: new URL(process.env.SALESFORCE_MCP_URL!),
        requestInit: {
            // User's specific token
            Authorization: `Bearer ${userCredentials.salesforceToken}`,
        },
      },
    },
  });

  const agent = mastra.getAgent('crmAgent');
  
  // Inject tools at runtime
  const response = await agent.generate(userPrompt, {
    toolsets: await userMcp.getToolsets(),
  });

  return response;
}
```

Each user gets their own isolated toolset with their own permissions. User A sees their deals, User B sees theirs. This is how multi-tenant SaaS agents work in practice.

---

## Building Composite Tools

Sometimes you need to combine multiple MCP tools into a single operation. Maybe you want to enrich a contact by pulling data from both Salesforce and LinkedIn.

You can wrap MCP tools in custom tool definitions:

```typescript
export const enrichmentTool = createTool({
  id: 'enrich-contact',
  description: 'Enriches contact data from Salesforce and LinkedIn',
  execute: async ({ context, mastra }) => {
    // Get the raw tools
    const tools = await mcpClient.getTools();
    
    // 1. Get base data from Salesforce
    const sfData = await tools.salesforce_lookupContact.execute({ 
      context: { email: context.email } 
    });
    
    // 2. Enhance with LinkedIn
    const linkedInData = await tools.linkedin_profileLookup.execute({
      context: { name: sfData.name }
    });
    
    // 3. Return the mega-profile
    return { ...sfData, ...linkedInData };
  },
});
```

This gives you fine-grained control over exactly how tools interact while still leveraging the MCP protocol for the heavy lifting.

---

## Where This Leads

Writing custom API clients for every service your AI agent needs to talk to was never sustainable. It scales badly, breaks often, and ties your platform to specific implementations.

MCP doesn't solve every integration challenge—auth is still complex, rate limiting still matters, and not every service has an MCP server yet. But it establishes a foundation that makes building agent platforms significantly less painful.

If you're architecting an AI system that needs to interact with external services, understanding MCP is probably worth your time.

### Resources

- [Mastra MCP Documentation](https://mastra.ai/docs/mcp/overview)
- [MCP Registry](https://registry.modelcontextprotocol.io)
- [Klavis AI (Enterprise MCP)](https://klavis.ai)
- [Mastra GitHub Repository](https://github.com/mastra-ai/mastra)

## Read the Series

1. [LLM Routing](/llm-routing-mastra-ai)
2. [Security & Guardrails](/mastra-security-guardrails)
3. **MCP & Tool Integrations** (This Post)
4. [Workflows & Memory](/mastra-workflows-memory)

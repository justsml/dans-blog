---
title: "Foreign Keys: The Debate Nobody Wins"
subTitle: "Both sides are wrong. Here's why."
date: 2025-12-29
modified: 2026-01-09
tags: [postgres, postgresql, databases, performance, foreign-keys, constraints, indexing]
category: Code
subCategory: Databases
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
---

A startup CTO once told me they removed all Foreign Keys to "optimize for web scale."

Six months later: 2.3 million orphaned records. Billing system charging deleted users. Analytics off by 40%.

**"But Foreign Keys are slow!"** they protested.

Sure. And seatbelts slow down your car. Should you remove those too?

---

## The "Performance" Myth

Yes, Foreign Keys add overhead. Every insert triggers a lookup. Every delete scans for references.

**The lie**: "This overhead matters."

**The truth**: Your application code doing the same validation is 10x slower and 100x buggier.

I've seen teams spend weeks building "application-level referential integrity" that:
- Misses edge cases (race conditions, anyone?)
- Breaks during deployments
- Gets bypassed by admin tools, scripts, and "temporary" fixes

All to save 2ms per insert.

Meanwhile, one missing index on a Foreign Key column costs you 2 *seconds* per delete. But nobody talks about that.

---

## The "Normalization" Cult

The other extreme: Database purists who normalize everything into oblivion.

Let's say you want to find out if you ordered the Red or the Blue T-Shirt?

**Their schema**: `Orders` → `OrderItems` → `Products` → `Variants` → `Colors` → `Sizes`

Six table joins. For a T-shirt.

**"But what if the brand's name for Blue changes?"**

If it does, do you *really* want historical orders to retroactively change color?

This is where "3rd Normal Form" becomes "3rd Circle of Hell."

Sometimes you don't need a Foreign Key. **You need a JSONB column.** Store `{"color": "blue", "size": "M"}` and move on with your life.

(See: [The JSONB Seduction](/the-jsonb-seduction) for when this backfires.)

---

## The "Scale" Excuse

**Popular opinion**: "Foreign Keys don't scale."

**Reality**: Scale is relative.

A Raspberry Pi weather station logging 10K sensor readings/minute? That's "high scale" for a microSD card.

AWS Aurora with provisioned IOPS? You can FK your way through billions of rows.

The real limit isn't scale—it's **sharding**. When `Users` live on Server A and `Orders` live on Server B, Foreign Keys physically cannot work.

But here's the kicker: If you're sharding, you've already traded database constraints for application complexity. You're running background jobs to find orphans. You're implementing "eventual consistency."

**You're doing the hard work anyway.**

So why are you optimizing for a problem you don't have yet by creating a data integrity problem you'll have *today*?

---

## The Hybrid Truth

The best engineers use blended strategies:

**Use Foreign Keys for**:
- Money (Invoices → Users)
- Auth (Sessions → Users)
- Anything where corruption = lawsuits

**Skip Foreign Keys for**:
- High-volume logs (1M events/min don't need validation)
- Historical snapshots (denormalize at write-time)
- Cross-shard references (physically impossible)

**Use JSONB for**:
- Data you fetch as a blob (user preferences)
- Schemas you don't control (webhook payloads)
- Historical records you'll never query by nested fields


## Conclusion

Foreign Keys are neither a silver bullet nor a performance killer.

They're a tool. Use them where corruption is expensive. Skip them where performance is critical and you have the discipline to validate in code.

But if you're removing FKs because you read a blog post about "web scale," you're cargo-culting Netflix's problems onto your 10-user SaaS.

**Pay the tax. Or don't. But know why.**

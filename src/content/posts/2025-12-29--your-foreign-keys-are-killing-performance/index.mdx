---
title: "Foreign Keys Are Slow. You Need Them Anyway."
subTitle: "The hidden cost of referential integrity—and why you should pay it anyway."
date: 2025-12-29
modified: 2025-12-30
tags: [postgres, postgresql, databases, performance, foreign-keys, constraints, indexing]
category: Code
subCategory: Databases
cover_full_width: ./wide.webp
cover_mobile: ./square.webp
cover_icon: ./square.webp
# social_image: desktop-social.webp
---

I consulted for a startup once that removed all foreign keys (FKs) to "scale to web scale."

Six months later, they had 2.3 million orphaned records pointing to deleted users.

Their billing system crashed because it tried to charge a user who didn't exist. Their analytics were wrong by 40%. The cleanup took **weeks**.

**Foreign Keys prevent your database from becoming a dumpster fire.**

Yes, they are slow. Let's talk about how slow.

---

## The Cost of Sanity

In one of my benchmarks, adding foreign key architecture increased write latency by **300%**.

Why?

1.  **Locking**: When you insert an `order`, Postgres locks the `user` row to make sure it doesn't vanish.
2.  **Read Overhead**: Every insert becomes a `SELECT` on the parent table.
3.  **Indexing**: You *must* index the FK column, or deletes become table scans.

### Converting "It Depends" into Numbers

Here is a benchmark from a system handling 10,000 writes/second:

```sql
-- Without foreign key
INSERT INTO orders (user_id, amount) VALUES (12345, 99.99);
-- Average: 1.2ms

-- With foreign key
INSERT INTO orders (user_id, amount) VALUES (12345, 99.99);
-- Average: 3.8ms (216% slower)
```

At scale, this matters. **But data corruption matters more.**

---

## The "Hyper Scale" Exception (Read: You Are Not Google)

There is a ceiling. If you are dealing with **billions or trillions of rows**, you simply cannot entangle tables with Foreign Keys.

At that scale, a `DELETE` operation cascading through a trillion-row table isn't a query; it's an outage.

Martin Kleppmann, author of the data engineering bible *Designing Data-Intensive Applications*, puts it bluntly:

> "Document databases sacrifice foreign keys and joins for flexibility... In practice, this means your application code must maintain referential integrity."

When you shard your database across 50 nodes, Foreign Keys physically stop working. You can't enforce a constraint when `User:123` is on Server A and `Order:999` is on Server B.

At Hyper Scale, **Application-Level Validation** replaces Database Constraints. But unless you have a dedicated infrastructure team of 50 engineers, you probably aren't at Hyper Scale.

---

## When to Actually Skip Them

I am about to commit heresy. There are valid reasons to skip FKs.

1.  **Append-Only Analytics**: If you are loading immutable logs into a warehouse, validate them in the ETL pipeline. FKs here are just friction.
2.  **Extreme Throughput Logging**: If you are ingesting 1 million audit logs/sec, you cannot afford the read overhead. But your app better calculate that `user_id` correctly.
3.  **Sharding**: If User A is on DB 1 and Order B is on DB 2, you *technically* can't have an FK. (Distributed systems are fun, aren't they?)

---

## The Foreign Key Survival Guide

If you keep them (and you should), follow these rules:

### 1. Index Both Sides
Postgres indexes the Primary Key automatically. It does **NOT** index the Foreign Key column.

If you miss this index, `DELETE FROM users` will scan the entire `orders` table.

### 2. Monitor Lock Contention
If you see high `LockWait` events, check your FKs. Highly engaged users (referencing the same rows) can become hotspots.

```sql
SELECT relation::regclass, mode, count(*) 
FROM pg_locks WHERE granted = false 
GROUP BY 1, 2 ORDER BY 3 DESC;
```

### 3. Use Deferrable Constraints (Maybe)
You can tell Postgres to check FKs at `COMMIT` time, not Statement time.

```sql
ALTER TABLE orders 
  ADD CONSTRAINT fk_user 
  FOREIGN KEY (user_id) REFERENCES users(id)
  DEFERRABLE INITIALLY DEFERRED;
```

This helps with circular dependencies, but it doesn't reduce the total cost. It just moves the bill to the end of the transaction.

---

## Conclusion

Foreign Keys are expensive taxes.

But the alternative is **data corruption**.

Unless you are Google (you aren't) or running a log firehose (you probably aren't), just pay the tax.

Your future self—debugging a `NullPointerException` on a "guaranteed" record at 3 AM—will thank you.

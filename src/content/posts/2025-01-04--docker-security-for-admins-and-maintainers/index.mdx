---
title: "Local Docker Security: The Lost Guide for Developers"
subTitle: "Learn how to protect your network from threats and dangerous configuration!"
date: 2025-01-05
modified: 2025-01-05
tags: [local development, security, devops, best-practices]
category: Security

cover_full_width: flame-whale-wide.webp
cover_mobile: flame-whale-head-square.webp
cover_icon: flame-whale-head-square.webp
cover_credit: ¬©Ô∏è 2025 Dan Levy
---

import {CodeTabs} from '../../../components/CodeTabs';


**Table of Contents**

1. [‚ö†Ô∏è Local Networks at Risk](#-local-networks-at-risk)
2. [üõ°Ô∏è Firewall Configuration](#-firewall-configuration)
3. [üîê Secrets Management for Local Development](#-secrets-management-for-local-development)
4. [üïµÔ∏è‚Äç Credential Leaks and Side-Channel Attacks](#-credential-leaks-and-side-channel-attacks)
5. [üîç Monitoring & Canary Tokens](#-monitoring--canary-tokens)
6. [‚ùå Common Misconceptions](#-common-misconceptions)


## ‚ö†Ô∏è Local Networks at Risk

Let‚Äôs be honest, we‚Äôve all done it. You‚Äôve connected to a random coffee shop Wi-Fi or let someone use your home network without a second thought. Maybe you even trust your smart fridge not to compromise your network. The reality? These casual decisions can expose your local development setup to unnecessary risks. Attackers don‚Äôt just target production systems‚Äîlocal environments are often softer targets, offering a way to access sensitive projects.

### Attack Scenarios

1. **Intercepted Traffic:** Unencrypted traffic can easily be captured and read.
2. **Unprotected Services:** Local databases or APIs exposed on `0.0.0.0`.
3. **Network Spoofing:** Redirects traffic to an attacker‚Äôs device.

### Quick Fixes

- Use firewalls to protect critical devices on your network.
- Avoid public or shared Wi-Fi; prefer using your phone's hotspot.
- Monitor your local network for unknown devices using tools like `arp-scan` and `nmap`.

## üõ°Ô∏è Firewall Configuration

### UFW with Docker (Ubuntu)

One of the common issues with Docker and UFW is that Docker modifies iptables rules, potentially bypassing your UFW configurations.

To mitigate this, download and install `ufw-docker`:

```bash
# Download `ufw-docker` script
sudo wget -O /usr/local/bin/ufw-docker \
   https://github.com/chaifeng/ufw-docker/raw/master/ufw-docker
sudo chmod +x /usr/local/bin/ufw-docker

# Install and modify the `after.rules` file of `ufw`
ufw-docker install
```

This command performs the following:

- Backs up the file `/etc/ufw/after.rules`.
- Appends Docker-related rules at the end of the file to integrate properly with UFW.

**Source:** [ufw-docker GitHub](https://github.com/chaifeng/ufw-docker/tree/master#install)

**Example Usage:**

```bash
# Allow Docker container on port 8080
ufw-docker allow <container_name> 8080/tcp

# Manage rules safely alongside your UFW configuration
ufw-docker status
```

**Note:** Most "fixes" for Docker-UFW conflicts involve manual iptables rules, which can be error-prone and fragile during updates.

### macOS Firewall

1. Go to **System Preferences > Security & Privacy > Firewall**.
2. Enable the firewall and click "Firewall Options."
3. Block all incoming connections except essential services.

**Note:** You may need to lookup configuration for your firewall to allow certain smart devices you use - e.g. Google Cast/AirPlay and other services.

### Commands for Advanced Users (macOS and Linux)

#### macOS:

```bash
sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setblockall on  # Block all
sudo /usr/libexec/ApplicationFirewall/socketfilterfw --add /path/to/app  # Allow specific app
```

#### Linux (ufw):

```bash
ufw default deny incoming  # Block all incoming
ufw allow ssh  # Allow SSH
# allow 443 and 80 for web traffic
ufw allow 80/tcp
ufw allow 443/tcp
ufw enable  # Enable firewall
```

**Pro Tip:** Use tools like [Little Snitch](https://www.obdev.at/products/littlesnitch/index.html) on macOS and [ufw](https://help.ubuntu.com/community/UFW) on Linux for more user-friendly configurations.

## üîê Secrets Management for Local Development

### Generating and Storing Secrets

<p class="inset">Never hardcode secrets in your codebase. Prefer environment variables and secure vaults.</p>

Instead of `.env.example`, use `.env.generate.sh` to make it easy for users to get a `.env` file with secure "defaults."

#### Example `.env.generate.sh`

```bash title=".env.generate.sh" frame="code"
#!/bin/bash
# Generates a secure .env file for local development

generate_secret() {
    local length=${1:-30}
    openssl rand -base64 "$length" | tr -d '+=/\n' | cut -c1-"$length"
}

# Bail out if .env file already exists
[ -f .env ] && { echo ".env file already exists!"; exit 1; }

cat <<EOL > .env
DB_USER=app_user
DB_PASSWORD=$(generate_secret 32)
REDIS_PASSWORD=$(generate_secret 32)
JWT_SECRET=$(generate_secret 32)
SESSION_KEY=$(generate_secret 32)
EOL

echo "New .env file generated!"
```

### Proactive Placeholder Validation

<p>Ensure your secrets are replaced with real values before running your application.</p>

<CodeTabs client:load tabs={["JavaScript", "Rust", "Go"]}>

```javascript
// validateSecrets.js
const validateSecrets = () => {
  const unsafePlaceholder = /PLACEHOLDER/;
  const missingSecrets = Object.entries(process.env).filter(
    ([key, value]) => unsafePlaceholder.test(value)
  );

  if (missingSecrets.length) {
    console.error("Unsafe secrets detected:", missingSecrets);
    process.exit(1);
  }
};

validateSecrets();
```

```rust
// validate_secrets.rs
use std::env;

fn validate_secrets() {
    let unsafe_placeholder = "PLACEHOLDER";
    for (key, value) in env::vars() {
        if value.contains(unsafe_placeholder) {
            panic!("Unsafe secret in {}", key);
        }
    }
}

fn main() {
    validate_secrets();
}
```

```go
// validate_secrets.go
package main

import (
	"fmt"
	"os"
	"strings"
)

func validateSecrets() {
	placeholder := "PLACEHOLDER"
	for _, env := range os.Environ() {
		pair := strings.SplitN(env, "=", 2)
		if len(pair) == 2 && strings.Contains(pair[1], placeholder) {
			panic(fmt.Sprintf("Unsafe secret in %s", pair[0]))
		}
	}
}

func main() {
	validateSecrets()
}
```

</CodeTabs>

{/* 
```zig
// validate_secrets.zig
const std = @import("std");

pub fn main() void {
    var env = std.os.getenv_map();
    const placeholder = "PLACEHOLDER";

    for (env.items()) |entry| {
        if (std.mem.contains(u8, entry.value, placeholder)) {
            std.debug.panic("Unsafe secret in {}", .{entry.key});
        }
    }
}
``` */}

## üïµÔ∏è‚Äç Monitoring & Double-checking

### `nmap` Examples

#### Testing Inside Your Network

```bash
# Scan your localhost for all open ports
nmap -sT localhost

# Scan your machine‚Äôs private IP for services
nmap -sV 192.168.1.10

# Detect devices on your network
nmap -sn 192.168.1.0/24
```

#### Testing Outside Your Network

To can lookup your current (public) IP easily with services like `ifconfig.me`: `curl https://ifconfig.me`.

Use an external network or remote server to test your public IPs:

```bash
# Scan public-facing services
nmap -Pn your-public-ip

# Check for specific open ports
nmap -p 80,443 your-public-ip
```

**Why Test Both?**
Testing from inside reveals internal exposure, while external tests identify services accessible to attackers.

## üõ°Ô∏è Common Misconceptions

1. **My local environment isn‚Äôt a target.**
   - Fact: Attackers can pivot from your machine to your production systems.
2. **Firewalls block everything.**
   - Fact: They only block what you configure them to.
3. **Private IPs are secure.**
   - Fact: Exploits like NAT bypasses can still affect your network.

